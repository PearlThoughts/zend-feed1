{
    "docs": [
        {
            "location": "/",
            "text": "zend-feed\n\n\n\n\n\n\nZend\\Feed\n provides functionality for consuming RSS and Atom feeds. It provides\na natural syntax for accessing elements of feeds, feed attributes, and entry\nattributes. \nZend\\Feed\n also has extensive support for modifying feed and entry\nstructure with the same natural syntax, and turning the result back into XML.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-feed/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-feed/",
            "title": "Home"
        },
        {
            "location": "/#zend-feed",
            "text": "Zend\\Feed  provides functionality for consuming RSS and Atom feeds. It provides\na natural syntax for accessing elements of feeds, feed attributes, and entry\nattributes.  Zend\\Feed  also has extensive support for modifying feed and entry\nstructure with the same natural syntax, and turning the result back into XML.   File issues at https://github.com/zendframework/zend-feed/issues  Documentation is at https://docs.zendframework.com/zend-feed/",
            "title": "zend-feed"
        },
        {
            "location": "/intro/",
            "text": "Introduction\n\n\nZend\\Feed\n provides functionality for consuming RSS and Atom feeds. It provides\na natural syntax for accessing elements of feeds, feed attributes, and entry\nattributes. \nZend\\Feed\n also has extensive support for modifying feed and entry\nstructure with the same natural syntax, and turning the result back into XML.\nIn the future, this modification support could provide support for the Atom\nPublishing Protocol.\n\n\nZend\\Feed\n consists of \nZend\\Feed\\Reader\n for reading RSS and Atom feeds,\n\nZend\\Feed\\Writer\n for writing RSS and Atom feeds, and \nZend\\Feed\\PubSubHubbub\n\nfor working with Hub servers. Furthermore, both \nZend\\Feed\\Reader\n and\n\nZend\\Feed\\Writer\n support extensions which allows for working with additional\ndata in feeds, not covered in the core API but used in conjunction with RSS and\nAtom feeds.\n\n\nIn the example below, we demonstrate a simple use case of retrieving an RSS feed\nand saving relevant portions of the feed data to a simple PHP array, which could\nthen be used for printing the data, storing to a database, etc.\n\n\n\n\nRSS optional properties\n\n\nMany \nRSS\n feeds have different channel and item properties available. The\n\nRSS\n specification provides for many optional properties, so be aware of this\nwhen writing code to work with \nRSS\n data. \nZend\\Feed\n supports all optional\nproperties of the core \nRSS\n and \nAtom\n specifications.\n\n\n\n\nReading RSS Feed Data\n\n\n// Fetch the latest Slashdot headlines\ntry {\n    $slashdotRss =\n        Zend\\Feed\\Reader\\Reader::import('http://rss.slashdot.org/Slashdot/slashdot');\n} catch (Zend\\Feed\\Reader\\Exception\\RuntimeException $e) {\n    // feed import failed\n    echo \"Exception caught importing feed: {$e->getMessage()}\\n\";\n    exit;\n}\n\n// Initialize the channel/feed data array\n$channel = [\n    'title'       => $slashdotRss->getTitle(),\n    'link'        => $slashdotRss->getLink(),\n    'description' => $slashdotRss->getDescription(),\n    'items'       => [],\n];\n\n// Loop over each channel item/entry and store relevant data for each\nforeach ($slashdotRss as $item) {\n    $channel['items'][] = [\n        'title'       => $item->getTitle(),\n        'link'        => $item->getLink(),\n        'description' => $item->getDescription(),\n    ];\n}\n\n\n\nYour \n$channel\n array now contains the basic meta-information for the RSS\nchannel and all items that it contained. The process is identical for Atom\nfeeds since \nZend\\Feed\n provides a common feed API; i.e. all getters and\nsetters are the same regardless of feed format.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#introduction",
            "text": "Zend\\Feed  provides functionality for consuming RSS and Atom feeds. It provides\na natural syntax for accessing elements of feeds, feed attributes, and entry\nattributes.  Zend\\Feed  also has extensive support for modifying feed and entry\nstructure with the same natural syntax, and turning the result back into XML.\nIn the future, this modification support could provide support for the Atom\nPublishing Protocol.  Zend\\Feed  consists of  Zend\\Feed\\Reader  for reading RSS and Atom feeds, Zend\\Feed\\Writer  for writing RSS and Atom feeds, and  Zend\\Feed\\PubSubHubbub \nfor working with Hub servers. Furthermore, both  Zend\\Feed\\Reader  and Zend\\Feed\\Writer  support extensions which allows for working with additional\ndata in feeds, not covered in the core API but used in conjunction with RSS and\nAtom feeds.  In the example below, we demonstrate a simple use case of retrieving an RSS feed\nand saving relevant portions of the feed data to a simple PHP array, which could\nthen be used for printing the data, storing to a database, etc.",
            "title": "Introduction"
        },
        {
            "location": "/intro/#rss-optional-properties",
            "text": "Many  RSS  feeds have different channel and item properties available. The RSS  specification provides for many optional properties, so be aware of this\nwhen writing code to work with  RSS  data.  Zend\\Feed  supports all optional\nproperties of the core  RSS  and  Atom  specifications.",
            "title": "RSS optional properties"
        },
        {
            "location": "/intro/#reading-rss-feed-data",
            "text": "// Fetch the latest Slashdot headlines\ntry {\n    $slashdotRss =\n        Zend\\Feed\\Reader\\Reader::import('http://rss.slashdot.org/Slashdot/slashdot');\n} catch (Zend\\Feed\\Reader\\Exception\\RuntimeException $e) {\n    // feed import failed\n    echo \"Exception caught importing feed: {$e->getMessage()}\\n\";\n    exit;\n}\n\n// Initialize the channel/feed data array\n$channel = [\n    'title'       => $slashdotRss->getTitle(),\n    'link'        => $slashdotRss->getLink(),\n    'description' => $slashdotRss->getDescription(),\n    'items'       => [],\n];\n\n// Loop over each channel item/entry and store relevant data for each\nforeach ($slashdotRss as $item) {\n    $channel['items'][] = [\n        'title'       => $item->getTitle(),\n        'link'        => $item->getLink(),\n        'description' => $item->getDescription(),\n    ];\n}  Your  $channel  array now contains the basic meta-information for the RSS\nchannel and all items that it contained. The process is identical for Atom\nfeeds since  Zend\\Feed  provides a common feed API; i.e. all getters and\nsetters are the same regardless of feed format.",
            "title": "Reading RSS Feed Data"
        },
        {
            "location": "/reader/",
            "text": "Zend\\Feed\\Reader\n\n\nZend\\Feed\\Reader\n is a component used to consume RSS and Atom feeds of\nany version, including RDF/RSS 1.0, RSS 2.0, Atom 0.3, and Atom 1.0. The API for\nretrieving feed data is deliberately simple since \nZend\\Feed\\Reader\n is capable\nof searching any feed of any type for the information requested through the API.\nIf the typical elements containing this information are not present, it will\nadapt and fall back on a variety of alternative elements instead. This ability\nto choose from alternatives removes the need for users to create their own\nabstraction layer on top of the component to make it useful or have any in-depth\nknowledge of the underlying standards, current alternatives, and namespaced\nextensions.\n\n\nInternally, the \nZend\\Feed\\Reader\\Reader\n class works almost entirely on the\nbasis of making XPath queries against the feed XML's Document Object Model. This\nsingular approach to parsing is consistent, and the component offers a plugin\nsystem to add to the Feed and Entry APIs by writing extensions on a similar\nbasis.\n\n\nPerformance is assisted in three ways. First of all, \nZend\\Feed\\Reader\\Reader\n\nsupports caching using \nzend-cache\n\nto maintain a copy of the original feed XML. This allows you to skip network\nrequests for a feed URI if the cache is valid. Second, the Feed and Entry APIs\nare backed by an internal cache (non-persistent) so repeat API calls for the\nsame feed will avoid additional DOM or XPath use. Thirdly, importing feeds from\na URI can take advantage of HTTP Conditional \nGET\n requests which allow servers\nto issue an empty 304 response when the requested feed has not changed since the\nlast time you requested it. In the final case, an zend-cache storage instance\nwill hold the last received feed along with the ETag and Last-Modified header\nvalues sent in the HTTP response.\n\n\nZend\\Feed\\Reader\\Reader\n is not capable of constructing feeds, and delegates\nthis responsibility to \nZend\\Feed\\Writer\\Writer\n.\n\n\nImporting Feeds\n\n\nFeeds can be imported from a string, file or a URI. Importing from a URI can\nadditionally utilise an HTTP Conditional \nGET\n request. If importing fails, an\nexception will be raised. The end result will be an object of type\n\nZend\\Feed\\Reader\\Feed\\AbstractFeed\n, the core implementations of which are\n\nZend\\Feed\\Reader\\Feed\\Rss\n and \nZend\\Feed\\Reader\\Feed\\Atom\n. Both objects\nsupport multiple (all existing) versions of these broad feed types.\n\n\nIn the following example, we import an RDF/RSS 1.0 feed and extract some basic\ninformation that can be saved to a database or elsewhere.\n\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n$data = [\n    'title'        => $feed->getTitle(),\n    'link'         => $feed->getLink(),\n    'dateModified' => $feed->getDateModified(),\n    'description'  => $feed->getDescription(),\n    'language'     => $feed->getLanguage(),\n    'entries'      => [],\n];\n\nforeach ($feed as $entry) {\n    $edata = [\n        'title'        => $entry->getTitle(),\n        'description'  => $entry->getDescription(),\n        'dateModified' => $entry->getDateModified(),\n        'authors'      => $entry->getAuthors(),\n        'link'         => $entry->getLink(),\n        'content'      => $entry->getContent(),\n    ];\n    $data['entries'][] = $edata;\n}\n\n\n\n\n\nImporting requires an HTTP client\n\n\nTo import a feed, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.\n\n\n\n\nThe example above demonstrates \nZend\\Feed\\Reader\\Reader\n's API, and it also\ndemonstrates some of its internal operation. In reality, the RDF feed selected\ndoes not have any native date or author elements; however it does utilise the\nDublin Core 1.1 module which offers namespaced creator and date elements.\n\nZend\\Feed\\Reader\\Reader\n falls back on these and similar options if no relevant\nnative elements exist. If it absolutely cannot find an alternative it will\nreturn \nNULL\n, indicating the information could not be found in the feed. You\nshould note that classes implementing \nZend\\Feed\\Reader\\Feed\\AbstractFeed\n also\nimplement the SPL \nIterator\n and \nCountable\n interfaces.\n\n\nFeeds can also be imported from strings or files.\n\n\n// from a URI\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n\n// from a String\n$feed = Zend\\Feed\\Reader\\Reader::importString($feedXmlString);\n\n// from a file\n$feed = Zend\\Feed\\Reader\\Reader::importFile('./feed.xml');\n\n\n\nRetrieving Underlying Feed and Entry Sources\n\n\nZend\\Feed\\Reader\\Reader\n does its best not to stick you in a narrow confine. If\nyou need to work on a feed outside of \nZend\\Feed\\Reader\\Reader\n, you can extract\nthe base DOMDocument or DOMElement objects from any class, or even an XML\nstring containing these. Also provided are methods to extract the current\nDOMXPath object (with all core and extension namespaces registered) and the\ncorrect prefix used in all XPath queries for the current feed or entry. The\nbasic methods to use (on any object) are \nsaveXml()\n, \ngetDomDocument()\n,\n\ngetElement()\n, \ngetXpath()\n and \ngetXpathPrefix()\n. These will let you break\nfree of \nZend\\Feed\\Reader\n and do whatever else you want.\n\n\n\n\nsaveXml()\n returns an XML string containing only the element representing the\n  current object.\n\n\ngetDomDocument()\n returns the DOMDocument object representing the entire feed\n  (even if called from an entry object).\n\n\ngetElement()\n returns the DOMElement of the current object (i.e. the feed or\n  current entry).\n\n\ngetXpath()\n returns the DOMXPath object for the current feed (even if called\n  from an entry object) with the namespaces of the current feed type and all\n  loaded extensions pre-registered.\n\n\ngetXpathPrefix()\n returns the query prefix for the current object (i.e. the\n  feed or current entry) which includes the correct XPath query path for that\n  specific feed or entry.\n\n\n\n\nLet's look at an example where a feed might include an RSS extension not\nsupported by \nZend\\Feed\\Reader\\Reader\n out of the box. Notably, you could write\nand register an extension (covered later) to do this, but that's not always\nwarranted for a quick check. You must register any new namespaces on the\nDOMXPath object before use unless they are registered by \nZend\\Feed\\Reader\n or\nan extension beforehand.\n\n\n$feed        = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n$xpathPrefix = $feed->getXpathPrefix();\n$xpath       = $feed->getXpath();\n$xpath->registerNamespace('admin', 'http://webns.net/mvcb/');\n$reportErrorsTo = $xpath->evaluate(\n    'string(' . $xpathPrefix . '/admin:errorReportsTo)'\n);\n\n\n\n\n\nDo not register duplicate namespaces\n\n\nIf you register an already registered namespace with a different prefix name\nto that used internally by \nZend\\Feed\\Reader\\Reader\n, it will break the\ninternal operation of this component.\n\n\n\n\nCache Support and Intelligent Requests\n\n\nAdding Cache Support to Zend\\Feed\\Reader\\Reader\n\n\nZend\\Feed\\Reader\\Reader\n supports using a\n\nzend-cache\n storage instance to\ncache feeds (as XML) to avoid unnecessary network requests. To add a cache,\ncreate and configure your cache instance, and then tell\n\nZend\\Feed\\Reader\\Reader\n to use it. The cache key used is\n\"\nZend\\Feed\\Reader\\\\\n\" followed by the MD5 hash of the feed's URI.\n\n\n$cache = Zend\\Cache\\StorageFactory::adapterFactory('Memory');\nZend\\Feed\\Reader\\Reader::setCache($cache);\n\n\n\nHTTP Conditional GET Support\n\n\nThe big question often asked when importing a feed frequently is if it has even\nchanged. With a cache enabled, you can add HTTP Conditional \nGET\n support to\nyour arsenal to answer that question.\n\n\nUsing this method, you can request feeds from URIs and include their last known\nETag and Last-Modified response header values with the request (using the\nIf-None-Match and If-Modified-Since headers). If the feed on the server remains\nunchanged, you should receive a 304 response which tells\n\nZend\\Feed\\Reader\\Reader\n to use the cached version. If a full feed is sent in a\nresponse with a status code of 200, this means the feed has changed and\n\nZend\\Feed\\Reader\\Reader\n will parse the new version and save it to the cache.\nIt will also cache the new ETag and Last-Modified header values for future use.\n\n\n\n\nConditional GET requires a HeaderAwareClientInterface\n\n\nConditional GET support only works for \nZend\\Feed\\Reader\\Http\\HeaderAwareClientInterface\n\nclient implementations, as it requires the ability to send HTTP headers.\n\n\n\n\nThese \"conditional\" requests are not guaranteed to be supported by the server\nyou request a \nURI\n of, but can be attempted regardless. Most common feed\nsources like blogs should however have this supported. To enable conditional\nrequests, you will need to provide a cache to \nZend\\Feed\\Reader\\Reader\n.\n\n\n$cache = Zend\\Cache\\StorageFactory::adapterFactory('Memory');\n\nZend\\Feed\\Reader\\Reader::setCache($cache);\nZend\\Feed\\Reader\\Reader::useHttpConditionalGet();\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n\n\n\nIn the example above, with HTTP Conditional \nGET\n requests enabled, the response\nheader values for ETag and Last-Modified will be cached along with the feed. For\nthe the cache's lifetime, feeds will only be updated on the cache if a non-304\nresponse is received containing a valid RSS or Atom XML document.\n\n\nIf you intend on managing request headers from outside\n\nZend\\Feed\\Reader\\Reader\n, you can set the relevant If-None-Matches and\nIf-Modified-Since request headers via the URI import method.\n\n\n$lastEtagReceived = '5e6cefe7df5a7e95c8b1ba1a2ccaff3d';\n$lastModifiedDateReceived = 'Wed, 08 Jul 2009 13:37:22 GMT';\n$feed = Zend\\Feed\\Reader\\Reader::import(\n    $uri, $lastEtagReceived, $lastModifiedDateReceived\n);\n\n\n\nLocating Feed URIs from Websites\n\n\nThese days, many websites are aware that the location of their XML feeds is not\nalways obvious. A small RDF, RSS, or Atom graphic helps when the user is reading\nthe page, but what about when a machine visits trying to identify where your\nfeeds are located? To assist in this, websites may point to their feeds using\n\n<link>\n tags in the \n<head>\n section of their HTML. To take advantage\nof this, you can use \nZend\\Feed\\Reader\\Reader\n to locate these feeds using the\nstatic \nfindFeedLinks()\n method.\n\n\nThis method calls any URI and searches for the location of RSS, RDF, and Atom\nfeeds assuming, the website's HTML contains the relevant links. It then returns\na value object where you can check for the existence of a RSS, RDF or Atom feed\nURI.\n\n\nThe returned object is an \nArrayObject\n subclass called\n\nZend\\Feed\\Reader\\FeedSet\n, so you can cast it to an array or iterate over it to\naccess all the detected links. However, as a simple shortcut, you can just grab\nthe first RSS, RDF, or Atom link using its public properties as in the example\nbelow. Otherwise, each element of the \nArrayObject\n is a simple array with the\nkeys \ntype\n and \nuri\n where the type is one of \"rdf\", \"rss\", or \"atom\".\n\n\n$links = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.planet-php.net');\n\nif (isset($links->rdf)) {\n    echo $links->rdf, \"\\n\"; // http://www.planet-php.org/rdf/\n}\nif (isset($links->rss)) {\n    echo $links->rss, \"\\n\"; // http://www.planet-php.org/rss/\n}\nif (isset($links->atom)) {\n    echo $links->atom, \"\\n\"; // http://www.planet-php.org/atom/\n}\n\n\n\nBased on these links, you can then import from whichever source you wish in the usual manner.\n\n\n\n\nFinding feed links requires an HTTP client\n\n\nTo find feed links, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.\n\n\n\n\nThis quick method only gives you one link for each feed type, but websites may\nindicate many links of any type. Perhaps it's a news site with a RSS feed for\neach news category. You can iterate over all links using the ArrayObject's\niterator.\n\n\n$links = Zend\\Feed\\Reader::findFeedLinks('http://www.planet-php.net');\n\nforeach ($links as $link) {\n    echo $link['href'], \"\\n\";\n}\n\n\n\nAttribute Collections\n\n\nIn an attempt to simplify return types, return types from the various feed and\nentry level methods may include an object of type\n\nZend\\Feed\\Reader\\Collection\\AbstractCollection\n. Despite the special class name\nwhich I'll explain below, this is just a simple subclass of SPL's \nArrayObject\n.\n\n\nThe main purpose here is to allow the presentation of as much data as possible\nfrom the requested elements, while still allowing access to the most relevant\ndata as a simple array. This also enforces a standard approach to returning such\ndata which previously may have wandered between arrays and objects.\n\n\nThe new class type acts identically to \nArrayObject\n with the sole addition\nbeing a new method \ngetValues()\n which returns a simple flat array containing\nthe most relevant information.\n\n\nA simple example of this is \nZend\\Feed\\Reader\\Reader\\FeedInterface::getCategories()\n.\nWhen used with any RSS or Atom feed, this method will return category data as a\ncontainer object called \nZend\\Feed\\Reader\\Collection\\Category\n. The container\nobject will contain, per category, three fields of data: term, scheme, and label.\nThe \"term\" is the basic category name, often machine readable (i.e. plays nice\nwith URIs). The scheme represents a categorisation scheme (usually a URI\nidentifier) also known as a \"domain\" in RSS 2.0. The \"label\" is a human readable\ncategory name which supports HTML entities. In RSS 2.0, there is no label\nattribute so it is always set to the same value as the term for convenience.\n\n\nTo access category labels by themselves in a simple value array, you might\ncommit to something like:\n\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.example.com/atom.xml');\n$categories = $feed->getCategories();\n$labels = [];\nforeach ($categories as $cat) {\n    $labels[] = $cat['label']\n}\n\n\n\nIt's a contrived example, but the point is that the labels are tied up with\nother information.\n\n\nHowever, the container class allows you to access the \"most relevant\" data as a\nsimple array using the \ngetValues()\n method. The concept of \"most relevant\" is\nobviously a judgement call. For categories it means the category labels (not the\nterms or schemes) while for authors it would be the authors' names (not their\nemail addresses or URIs). The simple array is flat (just values) and passed\nthrough \narray_unique()\n to remove duplication.\n\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.example.com/atom.xml');\n$categories = $feed->getCategories();\n$labels = $categories->getValues();\n\n\n\nThe above example shows how to extract only labels and nothing else thus giving\nsimple access to the category labels without any additional work to extract that\ndata by itself.\n\n\nRetrieving Feed Information\n\n\nRetrieving information from a feed (we'll cover entries and items in the next\nsection though they follow identical principals) uses a clearly defined API\nwhich is exactly the same regardless of whether the feed in question is RSS,\nRDF, or Atom. The same goes for sub-versions of these standards and we've tested\nevery single RSS and Atom version. While the underlying feed XML can differ\nsubstantially in terms of the tags and elements they present, they nonetheless\nare all trying to convey similar information and to reflect this all the\ndifferences and wrangling over alternative tags are handled internally by\n\nZend\\Feed\\Reader\\Reader\n presenting you with an identical interface for each.\nIdeally, you should not have to care whether a feed is RSS or Atom so long as\nyou can extract the information you want.\n\n\n\n\nRSS feeds vary widely\n\n\nWhile determining common ground between feed types is itself complex, it\nshould be noted that \nRSS\n in particular is a constantly disputed\n\"specification\". This has its roots in the original RSS 2.0 document, which\ncontains ambiguities and does not detail the correct treatment of all\nelements. As a result, this component rigorously applies the RSS 2.0.11\nSpecification published by the RSS Advisory Board and its accompanying RSS\nBest Practices Profile. No other interpretation of RSS\n2.0 will be supported, though exceptions may be allowed where it does not\ndirectly prevent the application of the two documents mentioned above.\n\n\n\n\nOf course, we don't live in an ideal world, so there may be times the API just\ndoes not cover what you're looking for. To assist you, \nZend\\Feed\\Reader\\Reader\n\noffers a plugin system which allows you to write extensions to expand the core\nAPI and cover any additional data you are trying to extract from feeds. If\nwriting another extension is too much trouble, you can simply grab the\nunderlying DOM or XPath objects and do it by hand in your application. Of\ncourse, we really do encourage writing an extension simply to make it more\nportable and reusable, and useful extensions may be proposed to the component\nfor formal addition.\n\n\nBelow is a summary of the Core API for feeds. You should note it comprises not\nonly the basic RSS and Atom standards, but also accounts for a number of\nincluded extensions bundled with \nZend\\Feed\\Reader\\Reader\n. The naming of these\nextension sourced methods remain fairly generic; all Extension methods operate\nat the same level as the Core API though we do allow you to retrieve any\nspecific extension object separately if required.\n\n\nFeed Level API Methods\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetId()\n\n\nReturns a unique ID associated with this feed\n\n\n\n\n\n\ngetTitle()\n\n\nReturns the title of the feed\n\n\n\n\n\n\ngetDescription()\n\n\nReturns the text description of the feed.\n\n\n\n\n\n\ngetLink()\n\n\nReturns a URI to the HTML website containing the same or similar information as this feed (i.e. if the feed is from a blog, it should provide the blog's URI where the HTML version of the entries can be read).\n\n\n\n\n\n\ngetFeedLink()\n\n\nReturns the URI of this feed, which may be the same as the URI used to import the feed. There are important cases where the feed link may differ because the source URI is being updated and is intended to be removed in the future.\n\n\n\n\n\n\ngetAuthors()\n\n\nReturns an object of type \nZend\\Feed\\Reader\\Collection\\Author\n which is an \nArrayObject\n whose elements are each simple arrays containing any combination of the keys \"name\", \"email\" and \"uri\". Where irrelevant to the source data, some of these keys may be omitted.\n\n\n\n\n\n\ngetAuthor(integer $index = 0)\n\n\nReturns either the first author known, or with the optional $index parameter any specific index on the array of authors as described above (returning \nNULL\n if an invalid index).\n\n\n\n\n\n\ngetDateCreated()\n\n\nReturns the date on which this feed was created. Generally only applicable to Atom, where it represents the date the resource described by an Atom 1.0 document was created. The returned date will be a \nDateTime\n object.\n\n\n\n\n\n\ngetDateModified()\n\n\nReturns the date on which this feed was last modified. The returned date will be a \nDateTime\n object.\n\n\n\n\n\n\ngetLastBuildDate()\n\n\nReturns the date on which this feed was last built. The returned date will be a \nDateTime\n object. This is only supported by RSS; Atom feeds will always return \nNULL\n.\n\n\n\n\n\n\ngetLanguage()\n\n\nReturns the language of the feed (if defined) or simply the language noted in the XML document.\n\n\n\n\n\n\ngetGenerator()\n\n\nReturns the generator of the feed, e.g. the software which generated it. This may differ between RSS and Atom since Atom defines a different notation.\n\n\n\n\n\n\ngetCopyright()\n\n\nReturns any copyright notice associated with the feed.\n\n\n\n\n\n\ngetHubs()\n\n\nReturns an array of all Hub Server URI endpoints which are advertised by the feed for use with the Pubsubhubbub Protocol, allowing subscriptions to the feed for real-time updates.\n\n\n\n\n\n\ngetCategories()\n\n\nReturns a \nZend\\Feed\\Reader\\Collection\\Category\n object containing the details of any categories associated with the overall feed. The supported fields include \"term\" (the machine readable category name), \"scheme\" (the categorisation scheme and domain for this category), and \"label\" (a HTML decoded human readable category name). Where any of the three fields are absent from the field, they are either set to the closest available alternative or, in the case of \"scheme\", set to \nNULL\n.\n\n\n\n\n\n\ngetImage()\n\n\nReturns an array containing data relating to any feed image or logo, or \nNULL\n if no image found. The resulting array may contain the following keys: uri, link, title, description, height, and width. Atom logos only contain a URI so the remaining metadata is drawn from RSS feeds only.\n\n\n\n\n\n\n\n\nGiven the variety of feeds in the wild, some of these methods will undoubtedly\nreturn \nNULL\n indicating the relevant information couldn't be located. Where\npossible, \nZend\\Feed\\Reader\\Reader\n will fall back on alternative elements\nduring its search. For example, searching an RSS feed for a modification date is\nmore complicated than it looks. RSS 2.0 feeds should include a \n<lastBuildDate>\n\ntag and/or a \n<pubDate>\n element. But what if it doesn't? Maybe this is an RSS\n1.0 feed? Perhaps it instead has an \n<atom:updated>\n element with identical\ninformation (Atom may be used to supplement RSS syntax)? Failing that, we\ncould simply look at the entries, pick the most recent, and use its \n<pubDate>\n\nelement. Assuming it exists, that is. Many feeds also use Dublin Core 1.0 or 1.1\n\n<dc:date>\n elements for feeds and entries. Or we could find Atom lurking again.\n\n\nThe point is, \nZend\\Feed\\Reader\\Reader\n was designed to know this. When you ask\nfor the modification date (or anything else), it will run off and search for all\nthese alternatives until it either gives up and returns \nNULL\n, or finds an\nalternative that should have the right answer.\n\n\nIn addition to the above methods, all feed objects implement methods for\nretrieving the DOM and XPath objects for the current feeds as described\nearlier. Feed objects also implement the SPL Iterator and Countable\ninterfaces. The extended API is summarised below.\n\n\nExtended Feed API Methods\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetDomDocument()\n\n\nReturns the parent DOMDocument object for the entire source XML document.\n\n\n\n\n\n\ngetElement()\n\n\nReturns the current feed level DOMElement object.\n\n\n\n\n\n\nsaveXml()\n\n\nReturns a string containing an XML document of the entire feed element (this is not the original document, but a rebuilt version).\n\n\n\n\n\n\ngetXpath()\n\n\nReturns the DOMXPath object used internally to run queries on the DOMDocument object (this includes core and extension namespaces pre-registered).\n\n\n\n\n\n\ngetXpathPrefix()\n\n\nReturns the valid DOM path prefix prepended to all XPath queries matching the feed being queried.\n\n\n\n\n\n\ngetEncoding()\n\n\nReturns the encoding of the source XML document (note: this cannot account for errors such as the server sending documents in a different encoding). Where not defined, the default UTF-8 encoding of Unicode is applied.\n\n\n\n\n\n\ncount()\n\n\nReturns a count of the entries or items this feed contains (implements SPL \nCountable\n interface)\n\n\n\n\n\n\ncurrent()\n\n\nReturns either the current entry (using the current index from \nkey()\n).\n\n\n\n\n\n\nkey()\n\n\nReturns the current entry index.\n\n\n\n\n\n\nnext()\n\n\nIncrements the entry index value by one.\n\n\n\n\n\n\nrewind()\n\n\nResets the entry index to 0.\n\n\n\n\n\n\nvalid()\n\n\nChecks that the current entry index is valid, i.e. it does not fall below 0 and does not exceed the number of entries existing.\n\n\n\n\n\n\ngetExtensions()\n\n\nReturns an array of all extension objects loaded for the current feed (note: both feed-level and entry-level extensions exist, and only feed-level extensions are returned here). The array keys are of the form \n{ExtensionName}_Feed\n.\n\n\n\n\n\n\ngetExtension(string $name)\n\n\nReturns an extension object for the feed registered under the provided name. This allows more fine-grained access to extensions which may otherwise be hidden within the implementation of the standard API methods.\n\n\n\n\n\n\ngetType()\n\n\nReturns a static class constant (e.g.  \nZend\\Feed\\Reader\\Reader::TYPE_ATOM_03\n, i.e. \"Atom 0.3\"), indicating exactly what kind of feed is being consumed.\n\n\n\n\n\n\n\n\nRetrieving Entry/Item Information\n\n\nRetrieving information for specific entries or items (depending on whether you\nspeak Atom or RSS) is identical to feed level data. Accessing entries is\nsimply a matter of iterating over a feed object or using the SPL \nIterator\n\ninterface feed objects implement, and calling the appropriate method on each.\n\n\nEntry API Methods\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetId()\n\n\nReturns a unique ID for the current entry.\n\n\n\n\n\n\ngetTitle()\n\n\nReturns the title of the current entry.\n\n\n\n\n\n\ngetDescription()\n\n\nReturns a description of the current entry.\n\n\n\n\n\n\ngetLink()\n\n\nReturns a URI to the HTML version of the current entry.\n\n\n\n\n\n\ngetPermaLink()\n\n\nReturns the permanent link to the current entry. In most cases, this is the same as using \ngetLink()\n.\n\n\n\n\n\n\ngetAuthors()\n\n\nReturns an object of type \nZend\\Feed\\Reader\\Collection\\Author\n, which is an \nArrayObject\n whose elements are each simple arrays containing any combination of the keys \"name\", \"email\" and \"uri\". Where irrelevant to the source data, some of these keys may be omitted.\n\n\n\n\n\n\ngetAuthor(integer $index = 0)\n\n\nReturns either the first author known, or, with the optional \n$index\n parameter, any specific index on the array of Authors as described above (returning \nNULL\n if an invalid index).\n\n\n\n\n\n\ngetDateCreated()\n\n\nReturns the date on which the current entry was created. Generally only applicable to Atom where it represents the date the resource described by an Atom 1.0 document was created.\n\n\n\n\n\n\ngetDateModified()\n\n\nReturns the date on which the current entry was last modified.\n\n\n\n\n\n\ngetContent()\n\n\nReturns the content of the current entry (this has any entities reversed if possible, assuming the content type is HTML). The description is returned if a separate content element does not exist.\n\n\n\n\n\n\ngetEnclosure()\n\n\nReturns class object (stdClass) containing the value of all attributes from a multi-media \n<enclosure>\n element including as class attributes: url, length, type. In accordance with the RSS Best Practices Profile of the RSS Advisory Board, no support is offers for multiple enclosures since such support forms no part of the RSS specification.\n\n\n\n\n\n\ngetCommentCount()\n\n\nReturns the number of comments made on this entry at the time the feed was last generated.\n\n\n\n\n\n\ngetCommentLink()\n\n\nReturns a URI pointing to the HTML page where comments can be made on this entry.\n\n\n\n\n\n\ngetCommentFeedLink([string $type = \u2018atom'|'rss'])\n\n\nReturns a URI pointing to a feed of the provided type containing all comments for this entry (type defaults to Atom/RSS depending on current feed type).\n\n\n\n\n\n\ngetCategories()\n\n\nReturns a \nZend\\Feed\\Reader\\Collection\\Category\n object containing the details of any categories associated with the entry. The supported fields include \"term\" (the machine readable category name), \"scheme\" (the categorisation scheme and domain for this category), and \"label\" (an HTML-decoded human readable category name). Where any of the three fields are absent from the field, they are either set to the closest available alternative or, in the case of \"scheme\", set to \nNULL\n.\n\n\n\n\n\n\n\n\nThe extended API for entries is identical to that for feeds with the exception\nof the \nIterator\n methods, which are not needed here.\n\n\n\n\nModified vs Created dates\n\n\nThere is often confusion over the concepts of \nmodified\n and \ncreated\n dates.\nIn Atom, these are two clearly defined concepts (so knock yourself out) but in\nRSS they are vague. RSS 2.0 defines a single \n<pubDate>\n element which\ntypically refers to the date this entry was published, i.e.  a creation date of\nsorts. This is not always the case, and it may change with updates or not. As a\nresult, if you really want to check whether an entry has changed, don't rely on\nthe results of \ngetDateModified()\n. Instead, consider tracking the MD5 hash of\nthree other elements concatenated, e.g. using \ngetTitle()\n, \ngetDescription()\n,\nand \ngetContent()\n. If the entry was truly updated, this hash computation will\ngive a different result than previously saved hashes for the same entry. This\nis obviously content oriented, and will not assist in detecting changes to\nother relevant elements.  Atom feeds should not require such steps.\n\n\nFurther muddying the waters, dates in feeds may follow different standards.\nAtom and Dublin Core dates should follow ISO 8601, and RSS dates should\nfollow RFC 822 or RFC 2822 (which is also common). Date methods will throw an\nexception if \nDateTime\n cannot load the date string using one of the above\nstandards, or the PHP recognised possibilities for RSS dates.\n\n\nValidation\n\n\nThe values returned from these methods are not validated. This means users\nmust perform validation on all retrieved data including the filtering of any\nHTML such as from \ngetContent()\n before it is output from your application.\nRemember that most feeds come from external sources, and therefore the default\nassumption should be that they cannot be trusted.\n\n\n\n\nExtended Entry Level API Methods\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ngetDomDocument()\n\n\nReturns the parent DOMDocument object for the entire feed (not just the current entry).\n\n\n\n\n\n\ngetElement()\n\n\nReturns the current entry level DOMElement object.\n\n\n\n\n\n\ngetXpath()\n\n\nReturns the DOMXPath object used internally to run queries on the DOMDocument object (this includes core and extension namespaces pre-registered).\n\n\n\n\n\n\ngetXpathPrefix()\n\n\nReturns the valid DOM path prefix prepended to all XPath queries matching the entry being queried.\n\n\n\n\n\n\ngetEncoding()\n\n\nReturns the encoding of the source XML document (note: this cannot account for errors such as the server sending documents in a different encoding). The default encoding applied in the absence of any other is the UTF-8 encoding of Unicode.\n\n\n\n\n\n\ngetExtensions()\n\n\nReturns an array of all extension objects loaded for the current entry (note: both feed-level and entry-level extensions exist, and only entry-level extensions are returned here). The array keys are in the form \n{ExtensionName}Entry\n.\n\n\n\n\n\n\ngetExtension(string $name)\n\n\nReturns an extension object for the entry registered under the provided name. This allows more fine-grained access to extensions which may otherwise be hidden within the implementation of the standard API methods.\n\n\n\n\n\n\ngetType()\n\n\nReturns a static class constant (e.g. \nZend\\Feed\\Reader\\Reader::TYPE_ATOM_03\n, i.e. \"Atom 0.3\") indicating exactly what kind of feed is being consumed.\n\n\n\n\n\n\n\n\nExtending Feed and Entry APIs\n\n\nExtending \nZend\\Feed\\Reader\\Reader\n allows you to add methods at both the feed\nand entry level which cover the retrieval of information not already supported\nby \nZend\\Feed\\Reader\\Reader\n. Given the number of RSS and Atom extensions that\nexist, this is a good thing, since \nZend\\Feed\\Reader\\Reader\n couldn't possibly\nadd everything.\n\n\nThere are two types of extensions possible, those which retrieve information\nfrom elements which are immediate children of the root element (e.g.\n\n<channel>\n for RSS or \n<feed>\n for Atom), and those who retrieve information\nfrom child elements of an entry (e.g. \n<item>\n for RSS or \n<entry>\n for Atom).\nOn the filesystem, these are grouped as classes within a namespace based on the\nextension standard's name. For example, internally we have\n\nZend\\Feed\\Reader\\Extension\\DublinCore\\Feed\n and\n\nZend\\Feed\\Reader\\Extension\\DublinCore\\Entry\n classes which are two extensions\nimplementing Dublin Core 1.0 and 1.1 support.\n\n\nExtensions are loaded into \nZend\\Feed\\Reader\\Reader\n using an \"extension\nmanager\". Extension managers must implement \nZend\\Feed\\Reader\\ExtensionManagerInterface\n.\nThree implementations exist:\n\n\n\n\nZend\\Feed\\Reader\\StandaloneExtensionManager\n is a hard-coded implementation\n  seeded with all feed and entry implementations. You can add simple extensions\n  from it using \nadd\n and \nremove\n methods. \nExtensionPluginManager\n is\n  recommended for more complex needs.\n\n\nZend\\Feed\\Reader\\ExtensionPluginManager\n is a \nZend\\ServiceManager\\AbstractPluginManager\n\n  implementation, \nZend\\Feed\\Reader\\ExtensionManager\n; as such, you can extend\n  it to add more extensions, use a \nZend\\ServiceManager\\ConfigInterface\n instance\n  to inject it with more extensions, or use its public API for adding services\n  (e.g., \nsetService()\n, \nsetFactory()\n, etc.). This implementation \ndoes not\n\n  implement \nExtensionManagerInterface\n, and must be used with \nExtensionManager\n.\n\n\nZend\\Feed\\Reader\\ExtensionManager\n exists for legacy purposes; prior to 2.3,\n  this was an \nAbstractPluginManager\n implementation, and the only provided\n  extension manager. It now implements \nExtensionManagerInterface\n, and acts as\n  a decorator for \nExtensionPluginManager\n.\n\n\n\n\nBy default, \nZend\\Feed\\Reader\\Reader\n composes a \nStandaloneExtensionManager\n. You\ncan inject an alternate implementation using \nReader::setExtensionManager()\n:\n\n\n$extensions = new Zend\\Feed\\Reader\\ExtensionPluginManager();\nZend\\Feed\\Reader\\Reader::setExtensionManager(\n    new ExtensionManager($extensions)\n);\n\n\n\nThe shipped implementations all provide the default extensions (so-called\n\"Core Extensions\") used internally by \nZend\\Feed\\Reader\\Reader\n. These\ninclude:\n\n\n\n\n\n\n\n\nExtension\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nDublinCore (Feed and Entry)\n\n\nImplements support for Dublin Core Metadata Element Set 1.0 and 1.1.\n\n\n\n\n\n\nContent (Entry only)\n\n\nImplements support for Content 1.0.\n\n\n\n\n\n\nAtom (Feed and Entry)\n\n\nImplements support for Atom 0.3 and Atom 1.0.\n\n\n\n\n\n\nSlash\n\n\nImplements support for the Slash RSS 1.0 module.\n\n\n\n\n\n\nWellFormedWeb\n\n\nImplements support for the Well Formed Web CommentAPI 1.0.\n\n\n\n\n\n\nThread\n\n\nImplements support for Atom Threading Extensions as described in RFC 4685.\n\n\n\n\n\n\nPodcast\n\n\nImplements support for the Podcast 1.0 DTD from Apple.\n\n\n\n\n\n\n\n\nThe core extensions are somewhat special since they are extremely common and\nmulti-faceted. For example, we have a core extension for Atom. Atom is\nimplemented as an extension (not just a base class) because it doubles as a\nvalid RSS module; you can insert Atom elements into RSS feeds.  I've even seen\nRDF feeds which use a lot of Atom in place of more common extensions like\nDublin Core.\n\n\nThe following is a list of non-Core extensions that are offered, but not registered\nby default. If you want to use them, you'll need to\ntell \nZend\\Feed\\Reader\\Reader\n to load them in advance of importing a feed.\nAdditional non-Core extensions will be included in future iterations of the\ncomponent.\n\n\n\n\n\n\n\n\nExtension\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSyndication\n\n\nImplements Syndication 1.0 support for RSS feeds.\n\n\n\n\n\n\nCreativeCommons\n\n\nAn RSS module that adds an element at the \n<channel>\n or \n<item>\n level that specifies which Creative Commons license applies.\n\n\n\n\n\n\n\n\nZend\\Feed\\Reader\\Reader\n requires you to explicitly register non-Core\nextensions in order to expose their API to feed and entry objects.  Below, we\nregister the optional Syndication extension, and discover that it can be\ndirectly called from the entry API without any effort. (Note that\nextension names are case sensitive and use camelCasing for multiple terms.)\n\n\nuse Zend\\Feed\\Reader\\Reader;\n\nReader::registerExtension('Syndication');\n$feed = Reader::import('http://rss.slashdot.org/Slashdot/slashdot');\n$updatePeriod = $feed->getUpdatePeriod();\n\n\n\nIn the simple example above, we checked how frequently a feed is being updated\nusing the \ngetUpdatePeriod()\n method. Since it's not part of\n\nZend\\Feed\\Reader\\Reader\n's core API, it could only be a method supported by\nthe newly registered Syndication extension.\n\n\nAs you can also notice, methods provided by extensions are accessible from the\nmain API using method overloading. As an alternative, you can also directly\naccess any extension object for a similar result as seen below.\n\n\nuse Zend\\Feed\\Reader\\Reader;\n\nReader::registerExtension('Syndication');\n$feed = Reader::import('http://rss.slashdot.org/Slashdot/slashdot');\n$syndication = $feed->getExtension('Syndication');\n$updatePeriod = $syndication->getUpdatePeriod();\n\n\n\nWriting Zend\\Feed\\Reader Extensions\n\n\nInevitably, there will be times when the \nZend\\Feed\\Reader\n API is just\nnot capable of getting something you need from a feed or entry. You can use the\nunderlying source objects, like DOMDocument, to get these by hand; however, there\nis a more reusable method available: you can write extensions supporting these new\nqueries.\n\n\nAs an example, let's take the case of a purely fictitious corporation named\nJungle Books. Jungle Books have been publishing a lot of reviews on books they\nsell (from external sources and customers), which are distributed as an RSS 2.0\nfeed. Their marketing department realises that web applications using this feed\ncannot currently figure out exactly what book is being reviewed. To make life\neasier for everyone, they determine that the geek department needs to extend\nRSS 2.0 to include a new element per entry supplying the ISBN-10 or ISBN-13\nnumber of the publication the entry concerns. They define the new \n<isbn>\n\nelement quite simply with a standard name and namespace URI:\n\n\n\n\nName: JungleBooks 1.0\n\n\nNamespace URI: http://example.com/junglebooks/rss/module/1.0/\n\n\n\n\nA snippet of RSS containing this extension in practice could be something\nsimilar to:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<rss version=\"2.0\"\n   xmlns:content=\"http://purl.org/rss/1.0/modules/content/\"\n   xmlns:jungle=\"http://example.com/junglebooks/rss/module/1.0/\">\n<channel>\n    <title>Jungle Books Customer Reviews</title>\n    <link>http://example.com/junglebooks</link>\n    <description>Many book reviews!</description>\n    <pubDate>Fri, 26 Jun 2009 19:15:10 GMT</pubDate>\n    <jungle:dayPopular>\n        http://example.com/junglebooks/book/938\n    </jungle:dayPopular>\n    <item>\n        <title>Review Of Flatland: A Romance of Many Dimensions</title>\n        <link>http://example.com/junglebooks/review/987</link>\n        <author>Confused Physics Student</author>\n        <content:encoded>\n        A romantic square?!\n        </content:encoded>\n        <pubDate>Thu, 25 Jun 2009 20:03:28 -0700</pubDate>\n        <jungle:isbn>048627263X</jungle:isbn>\n    </item>\n</channel>\n</rss>\n\n\n\nImplementing this new ISBN element as a simple entry level extension would\nrequire the following class (using your own namespace).\n\n\nnamespace My\\FeedReader\\Extension\\JungleBooks;\n\nuse Zend\\Feed\\Reader\\Extension\\AbstractEntry;\n\nclass Entry extends AbstractEntry\n{\n    public function getIsbn()\n    {\n        if (isset($this->data['isbn'])) {\n            return $this->data['isbn'];\n        }\n\n        $isbn = $this->xpath->evaluate(\n            'string(' . $this->getXpathPrefix() . '/jungle:isbn)'\n        );\n\n        if (! $isbn) {\n            $isbn = null;\n        }\n\n        $this->data['isbn'] = $isbn;\n        return $this->data['isbn'];\n    }\n\n    protected function registerNamespaces()\n    {\n        $this->xpath->registerNamespace(\n            'jungle',\n            'http://example.com/junglebooks/rss/module/1.0/'\n        );\n    }\n}\n\n\n\nThis extension creates a new method \ngetIsbn()\n, which runs an XPath query on\nthe current entry to extract the ISBN number enclosed by the \n<jungle:isbn>\n\nelement. It can optionally store this to the internal non-persistent cache (no\nneed to keep querying the DOM if it's called again on the same entry). The\nvalue is returned to the caller. At the end we have a protected method (it's\nabstract, making it required by implementations) which registers the Jungle\nBooks namespace for their custom RSS module. While we call this an RSS module,\nthere's nothing to prevent the same element being used in Atom feeds; all\nextensions which use the prefix provided by \ngetXpathPrefix()\n are actually\nneutral and work on RSS or Atom feeds with no extra code.\n\n\nSince this extension is stored outside of zend-feed, you'll need to ensure your\napplication can autoload it. Once that's in place, you will also need to ensure\nyour extension manager knows about it, and then register the extension with\n\nZend\\Feed\\Reader\\Reader\n.\n\n\nThe following example uses \nZend\\Feed\\Reader\\ExtensionPluginManager\n to manage\nextensions, as it provides the ability to register new extensions without\nrequiring extension of the plugin manager itself (note that this example works\nwith ServiceManager v2, but not v3). To use it, first install\nzend-servicemanager:\n\n\n$ composer require zendframework/zend-servicemanager\n\n\n\nFrom there:\n\n\nuse My\\FeedReader\\Extension\\JungleBooks;\nuse Zend\\Feed\\Reader\\ExtensionManager;\nuse Zend\\Feed\\Reader\\ExtensionPluginManager;\nuse Zend\\Feed\\Reader\\Reader;\n\n$extensions = new ExtensionPluginManager();\n$extensions->setInvokableClass('JungleBooks\\Entry', JungleBooks\\Entry::class);\nReader::setExtensionManager(new ExtensionManager($extensions));\nReader::registerExtension('JungleBooks');\n\n$feed = Reader::import('http://example.com/junglebooks/rss');\n\n// ISBN for whatever book the first entry in the feed was concerned with\n$firstIsbn = $feed->current()->getIsbn();\n\n\n\nWriting a feed extension is not much different. The example feed from earlier\nincluded an unmentioned \n<jungle:dayPopular>\n element which Jungle Books have\nadded to their standard to include a link to the day's most popular book (in\nterms of visitor traffic). Here's an extension which adds a\n\ngetDaysPopularBookLink()\n method to the feel level API.\n\n\nnamespace My\\FeedReader\\Extension\\JungleBooks;\n\nuse Zend\\Feed\\Reader\\Extension\\AbstractFeed;\n\nclass Feed extends AbstractFeed\n{\n    public function getDaysPopularBookLink()\n    {\n        if (isset($this->data['dayPopular'])) {\n            return $this->data['dayPopular'];\n        }\n\n        $dayPopular = $this->xpath->evaluate(\n            'string(' . $this->getXpathPrefix() . '/jungle:dayPopular)'\n        );\n\n        if (!$dayPopular) {\n            $dayPopular = null;\n        }\n\n        $this->data['dayPopular'] = $dayPopular;\n        return $this->data['dayPopular'];\n    }\n\n    protected function registerNamespaces()\n    {\n        $this->xpath->registerNamespace(\n            'jungle',\n            'http://example.com/junglebooks/rss/module/1.0/'\n        );\n    }\n}\n\n\n\nLet's add to the previous example; we'll register the new class with the\nextension manager, and then demonstrate using the newly exposed method:\n\n\nuse My\\FeedReader\\Extension\\JungleBooks;\nuse Zend\\Feed\\Reader\\ExtensionManager;\nuse Zend\\Feed\\Reader\\ExtensionPluginManager;\nuse Zend\\Feed\\Reader\\Reader;\n\n$extensions = new ExtensionPluginManager();\n$extensions->setInvokableClass('JungleBooks\\Entry', JungleBooks\\Entry::class);\n$extensions->setInvokableClass('JungleBooks\\Feed', JungleBooks\\Feed::class);\nReader::setExtensionManager(new ExtensionManager($extensions));\nReader::registerExtension('JungleBooks');\n\n$feed = Reader::import('http://example.com/junglebooks/rss');\n\n// URI to the information page of the day's most popular book with visitors\n$daysPopularBookLink = $feed->getDaysPopularBookLink();\n\n\n\nGoing through these examples, you'll note that while we need to register the\nfeed and entry classes separately with the plugin manager, we don't register\nthem separately when registering the extension with the \nReader\n.  Extensions\nwithin the same standard may or may not include both a feed and entry class, so\n\nZend\\Feed\\Reader\\Reader\n only requires you to register the overall parent name,\ne.g.  JungleBooks, DublinCore, Slash. Internally, it can check at what level\nextensions exist and load them up if found. In our case, we have a complete\nextension now, spanning the classes \nJungleBooks\\Feed\n and \nJungleBooks\\Entry\n.",
            "title": "Zend\\Feed\\Reader"
        },
        {
            "location": "/reader/#zend92feed92reader",
            "text": "Zend\\Feed\\Reader  is a component used to consume RSS and Atom feeds of\nany version, including RDF/RSS 1.0, RSS 2.0, Atom 0.3, and Atom 1.0. The API for\nretrieving feed data is deliberately simple since  Zend\\Feed\\Reader  is capable\nof searching any feed of any type for the information requested through the API.\nIf the typical elements containing this information are not present, it will\nadapt and fall back on a variety of alternative elements instead. This ability\nto choose from alternatives removes the need for users to create their own\nabstraction layer on top of the component to make it useful or have any in-depth\nknowledge of the underlying standards, current alternatives, and namespaced\nextensions.  Internally, the  Zend\\Feed\\Reader\\Reader  class works almost entirely on the\nbasis of making XPath queries against the feed XML's Document Object Model. This\nsingular approach to parsing is consistent, and the component offers a plugin\nsystem to add to the Feed and Entry APIs by writing extensions on a similar\nbasis.  Performance is assisted in three ways. First of all,  Zend\\Feed\\Reader\\Reader \nsupports caching using  zend-cache \nto maintain a copy of the original feed XML. This allows you to skip network\nrequests for a feed URI if the cache is valid. Second, the Feed and Entry APIs\nare backed by an internal cache (non-persistent) so repeat API calls for the\nsame feed will avoid additional DOM or XPath use. Thirdly, importing feeds from\na URI can take advantage of HTTP Conditional  GET  requests which allow servers\nto issue an empty 304 response when the requested feed has not changed since the\nlast time you requested it. In the final case, an zend-cache storage instance\nwill hold the last received feed along with the ETag and Last-Modified header\nvalues sent in the HTTP response.  Zend\\Feed\\Reader\\Reader  is not capable of constructing feeds, and delegates\nthis responsibility to  Zend\\Feed\\Writer\\Writer .",
            "title": "Zend\\Feed\\Reader"
        },
        {
            "location": "/reader/#importing-feeds",
            "text": "Feeds can be imported from a string, file or a URI. Importing from a URI can\nadditionally utilise an HTTP Conditional  GET  request. If importing fails, an\nexception will be raised. The end result will be an object of type Zend\\Feed\\Reader\\Feed\\AbstractFeed , the core implementations of which are Zend\\Feed\\Reader\\Feed\\Rss  and  Zend\\Feed\\Reader\\Feed\\Atom . Both objects\nsupport multiple (all existing) versions of these broad feed types.  In the following example, we import an RDF/RSS 1.0 feed and extract some basic\ninformation that can be saved to a database or elsewhere.  $feed = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n$data = [\n    'title'        => $feed->getTitle(),\n    'link'         => $feed->getLink(),\n    'dateModified' => $feed->getDateModified(),\n    'description'  => $feed->getDescription(),\n    'language'     => $feed->getLanguage(),\n    'entries'      => [],\n];\n\nforeach ($feed as $entry) {\n    $edata = [\n        'title'        => $entry->getTitle(),\n        'description'  => $entry->getDescription(),\n        'dateModified' => $entry->getDateModified(),\n        'authors'      => $entry->getAuthors(),\n        'link'         => $entry->getLink(),\n        'content'      => $entry->getContent(),\n    ];\n    $data['entries'][] = $edata;\n}",
            "title": "Importing Feeds"
        },
        {
            "location": "/reader/#importing-requires-an-http-client",
            "text": "To import a feed, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .   The example above demonstrates  Zend\\Feed\\Reader\\Reader 's API, and it also\ndemonstrates some of its internal operation. In reality, the RDF feed selected\ndoes not have any native date or author elements; however it does utilise the\nDublin Core 1.1 module which offers namespaced creator and date elements. Zend\\Feed\\Reader\\Reader  falls back on these and similar options if no relevant\nnative elements exist. If it absolutely cannot find an alternative it will\nreturn  NULL , indicating the information could not be found in the feed. You\nshould note that classes implementing  Zend\\Feed\\Reader\\Feed\\AbstractFeed  also\nimplement the SPL  Iterator  and  Countable  interfaces.  Feeds can also be imported from strings or files.  // from a URI\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n\n// from a String\n$feed = Zend\\Feed\\Reader\\Reader::importString($feedXmlString);\n\n// from a file\n$feed = Zend\\Feed\\Reader\\Reader::importFile('./feed.xml');",
            "title": "Importing requires an HTTP client"
        },
        {
            "location": "/reader/#retrieving-underlying-feed-and-entry-sources",
            "text": "Zend\\Feed\\Reader\\Reader  does its best not to stick you in a narrow confine. If\nyou need to work on a feed outside of  Zend\\Feed\\Reader\\Reader , you can extract\nthe base DOMDocument or DOMElement objects from any class, or even an XML\nstring containing these. Also provided are methods to extract the current\nDOMXPath object (with all core and extension namespaces registered) and the\ncorrect prefix used in all XPath queries for the current feed or entry. The\nbasic methods to use (on any object) are  saveXml() ,  getDomDocument() , getElement() ,  getXpath()  and  getXpathPrefix() . These will let you break\nfree of  Zend\\Feed\\Reader  and do whatever else you want.   saveXml()  returns an XML string containing only the element representing the\n  current object.  getDomDocument()  returns the DOMDocument object representing the entire feed\n  (even if called from an entry object).  getElement()  returns the DOMElement of the current object (i.e. the feed or\n  current entry).  getXpath()  returns the DOMXPath object for the current feed (even if called\n  from an entry object) with the namespaces of the current feed type and all\n  loaded extensions pre-registered.  getXpathPrefix()  returns the query prefix for the current object (i.e. the\n  feed or current entry) which includes the correct XPath query path for that\n  specific feed or entry.   Let's look at an example where a feed might include an RSS extension not\nsupported by  Zend\\Feed\\Reader\\Reader  out of the box. Notably, you could write\nand register an extension (covered later) to do this, but that's not always\nwarranted for a quick check. You must register any new namespaces on the\nDOMXPath object before use unless they are registered by  Zend\\Feed\\Reader  or\nan extension beforehand.  $feed        = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');\n$xpathPrefix = $feed->getXpathPrefix();\n$xpath       = $feed->getXpath();\n$xpath->registerNamespace('admin', 'http://webns.net/mvcb/');\n$reportErrorsTo = $xpath->evaluate(\n    'string(' . $xpathPrefix . '/admin:errorReportsTo)'\n);",
            "title": "Retrieving Underlying Feed and Entry Sources"
        },
        {
            "location": "/reader/#do-not-register-duplicate-namespaces",
            "text": "If you register an already registered namespace with a different prefix name\nto that used internally by  Zend\\Feed\\Reader\\Reader , it will break the\ninternal operation of this component.",
            "title": "Do not register duplicate namespaces"
        },
        {
            "location": "/reader/#cache-support-and-intelligent-requests",
            "text": "",
            "title": "Cache Support and Intelligent Requests"
        },
        {
            "location": "/reader/#adding-cache-support-to-zend92feed92reader92reader",
            "text": "Zend\\Feed\\Reader\\Reader  supports using a zend-cache  storage instance to\ncache feeds (as XML) to avoid unnecessary network requests. To add a cache,\ncreate and configure your cache instance, and then tell Zend\\Feed\\Reader\\Reader  to use it. The cache key used is\n\" Zend\\Feed\\Reader\\\\ \" followed by the MD5 hash of the feed's URI.  $cache = Zend\\Cache\\StorageFactory::adapterFactory('Memory');\nZend\\Feed\\Reader\\Reader::setCache($cache);",
            "title": "Adding Cache Support to Zend\\Feed\\Reader\\Reader"
        },
        {
            "location": "/reader/#http-conditional-get-support",
            "text": "The big question often asked when importing a feed frequently is if it has even\nchanged. With a cache enabled, you can add HTTP Conditional  GET  support to\nyour arsenal to answer that question.  Using this method, you can request feeds from URIs and include their last known\nETag and Last-Modified response header values with the request (using the\nIf-None-Match and If-Modified-Since headers). If the feed on the server remains\nunchanged, you should receive a 304 response which tells Zend\\Feed\\Reader\\Reader  to use the cached version. If a full feed is sent in a\nresponse with a status code of 200, this means the feed has changed and Zend\\Feed\\Reader\\Reader  will parse the new version and save it to the cache.\nIt will also cache the new ETag and Last-Modified header values for future use.",
            "title": "HTTP Conditional GET Support"
        },
        {
            "location": "/reader/#conditional-get-requires-a-headerawareclientinterface",
            "text": "Conditional GET support only works for  Zend\\Feed\\Reader\\Http\\HeaderAwareClientInterface \nclient implementations, as it requires the ability to send HTTP headers.   These \"conditional\" requests are not guaranteed to be supported by the server\nyou request a  URI  of, but can be attempted regardless. Most common feed\nsources like blogs should however have this supported. To enable conditional\nrequests, you will need to provide a cache to  Zend\\Feed\\Reader\\Reader .  $cache = Zend\\Cache\\StorageFactory::adapterFactory('Memory');\n\nZend\\Feed\\Reader\\Reader::setCache($cache);\nZend\\Feed\\Reader\\Reader::useHttpConditionalGet();\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rdf/');  In the example above, with HTTP Conditional  GET  requests enabled, the response\nheader values for ETag and Last-Modified will be cached along with the feed. For\nthe the cache's lifetime, feeds will only be updated on the cache if a non-304\nresponse is received containing a valid RSS or Atom XML document.  If you intend on managing request headers from outside Zend\\Feed\\Reader\\Reader , you can set the relevant If-None-Matches and\nIf-Modified-Since request headers via the URI import method.  $lastEtagReceived = '5e6cefe7df5a7e95c8b1ba1a2ccaff3d';\n$lastModifiedDateReceived = 'Wed, 08 Jul 2009 13:37:22 GMT';\n$feed = Zend\\Feed\\Reader\\Reader::import(\n    $uri, $lastEtagReceived, $lastModifiedDateReceived\n);",
            "title": "Conditional GET requires a HeaderAwareClientInterface"
        },
        {
            "location": "/reader/#locating-feed-uris-from-websites",
            "text": "These days, many websites are aware that the location of their XML feeds is not\nalways obvious. A small RDF, RSS, or Atom graphic helps when the user is reading\nthe page, but what about when a machine visits trying to identify where your\nfeeds are located? To assist in this, websites may point to their feeds using <link>  tags in the  <head>  section of their HTML. To take advantage\nof this, you can use  Zend\\Feed\\Reader\\Reader  to locate these feeds using the\nstatic  findFeedLinks()  method.  This method calls any URI and searches for the location of RSS, RDF, and Atom\nfeeds assuming, the website's HTML contains the relevant links. It then returns\na value object where you can check for the existence of a RSS, RDF or Atom feed\nURI.  The returned object is an  ArrayObject  subclass called Zend\\Feed\\Reader\\FeedSet , so you can cast it to an array or iterate over it to\naccess all the detected links. However, as a simple shortcut, you can just grab\nthe first RSS, RDF, or Atom link using its public properties as in the example\nbelow. Otherwise, each element of the  ArrayObject  is a simple array with the\nkeys  type  and  uri  where the type is one of \"rdf\", \"rss\", or \"atom\".  $links = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.planet-php.net');\n\nif (isset($links->rdf)) {\n    echo $links->rdf, \"\\n\"; // http://www.planet-php.org/rdf/\n}\nif (isset($links->rss)) {\n    echo $links->rss, \"\\n\"; // http://www.planet-php.org/rss/\n}\nif (isset($links->atom)) {\n    echo $links->atom, \"\\n\"; // http://www.planet-php.org/atom/\n}  Based on these links, you can then import from whichever source you wish in the usual manner.",
            "title": "Locating Feed URIs from Websites"
        },
        {
            "location": "/reader/#finding-feed-links-requires-an-http-client",
            "text": "To find feed links, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .   This quick method only gives you one link for each feed type, but websites may\nindicate many links of any type. Perhaps it's a news site with a RSS feed for\neach news category. You can iterate over all links using the ArrayObject's\niterator.  $links = Zend\\Feed\\Reader::findFeedLinks('http://www.planet-php.net');\n\nforeach ($links as $link) {\n    echo $link['href'], \"\\n\";\n}",
            "title": "Finding feed links requires an HTTP client"
        },
        {
            "location": "/reader/#attribute-collections",
            "text": "In an attempt to simplify return types, return types from the various feed and\nentry level methods may include an object of type Zend\\Feed\\Reader\\Collection\\AbstractCollection . Despite the special class name\nwhich I'll explain below, this is just a simple subclass of SPL's  ArrayObject .  The main purpose here is to allow the presentation of as much data as possible\nfrom the requested elements, while still allowing access to the most relevant\ndata as a simple array. This also enforces a standard approach to returning such\ndata which previously may have wandered between arrays and objects.  The new class type acts identically to  ArrayObject  with the sole addition\nbeing a new method  getValues()  which returns a simple flat array containing\nthe most relevant information.  A simple example of this is  Zend\\Feed\\Reader\\Reader\\FeedInterface::getCategories() .\nWhen used with any RSS or Atom feed, this method will return category data as a\ncontainer object called  Zend\\Feed\\Reader\\Collection\\Category . The container\nobject will contain, per category, three fields of data: term, scheme, and label.\nThe \"term\" is the basic category name, often machine readable (i.e. plays nice\nwith URIs). The scheme represents a categorisation scheme (usually a URI\nidentifier) also known as a \"domain\" in RSS 2.0. The \"label\" is a human readable\ncategory name which supports HTML entities. In RSS 2.0, there is no label\nattribute so it is always set to the same value as the term for convenience.  To access category labels by themselves in a simple value array, you might\ncommit to something like:  $feed = Zend\\Feed\\Reader\\Reader::import('http://www.example.com/atom.xml');\n$categories = $feed->getCategories();\n$labels = [];\nforeach ($categories as $cat) {\n    $labels[] = $cat['label']\n}  It's a contrived example, but the point is that the labels are tied up with\nother information.  However, the container class allows you to access the \"most relevant\" data as a\nsimple array using the  getValues()  method. The concept of \"most relevant\" is\nobviously a judgement call. For categories it means the category labels (not the\nterms or schemes) while for authors it would be the authors' names (not their\nemail addresses or URIs). The simple array is flat (just values) and passed\nthrough  array_unique()  to remove duplication.  $feed = Zend\\Feed\\Reader\\Reader::import('http://www.example.com/atom.xml');\n$categories = $feed->getCategories();\n$labels = $categories->getValues();  The above example shows how to extract only labels and nothing else thus giving\nsimple access to the category labels without any additional work to extract that\ndata by itself.",
            "title": "Attribute Collections"
        },
        {
            "location": "/reader/#retrieving-feed-information",
            "text": "Retrieving information from a feed (we'll cover entries and items in the next\nsection though they follow identical principals) uses a clearly defined API\nwhich is exactly the same regardless of whether the feed in question is RSS,\nRDF, or Atom. The same goes for sub-versions of these standards and we've tested\nevery single RSS and Atom version. While the underlying feed XML can differ\nsubstantially in terms of the tags and elements they present, they nonetheless\nare all trying to convey similar information and to reflect this all the\ndifferences and wrangling over alternative tags are handled internally by Zend\\Feed\\Reader\\Reader  presenting you with an identical interface for each.\nIdeally, you should not have to care whether a feed is RSS or Atom so long as\nyou can extract the information you want.",
            "title": "Retrieving Feed Information"
        },
        {
            "location": "/reader/#rss-feeds-vary-widely",
            "text": "While determining common ground between feed types is itself complex, it\nshould be noted that  RSS  in particular is a constantly disputed\n\"specification\". This has its roots in the original RSS 2.0 document, which\ncontains ambiguities and does not detail the correct treatment of all\nelements. As a result, this component rigorously applies the RSS 2.0.11\nSpecification published by the RSS Advisory Board and its accompanying RSS\nBest Practices Profile. No other interpretation of RSS\n2.0 will be supported, though exceptions may be allowed where it does not\ndirectly prevent the application of the two documents mentioned above.   Of course, we don't live in an ideal world, so there may be times the API just\ndoes not cover what you're looking for. To assist you,  Zend\\Feed\\Reader\\Reader \noffers a plugin system which allows you to write extensions to expand the core\nAPI and cover any additional data you are trying to extract from feeds. If\nwriting another extension is too much trouble, you can simply grab the\nunderlying DOM or XPath objects and do it by hand in your application. Of\ncourse, we really do encourage writing an extension simply to make it more\nportable and reusable, and useful extensions may be proposed to the component\nfor formal addition.  Below is a summary of the Core API for feeds. You should note it comprises not\nonly the basic RSS and Atom standards, but also accounts for a number of\nincluded extensions bundled with  Zend\\Feed\\Reader\\Reader . The naming of these\nextension sourced methods remain fairly generic; all Extension methods operate\nat the same level as the Core API though we do allow you to retrieve any\nspecific extension object separately if required.",
            "title": "RSS feeds vary widely"
        },
        {
            "location": "/reader/#feed-level-api-methods",
            "text": "Method  Description      getId()  Returns a unique ID associated with this feed    getTitle()  Returns the title of the feed    getDescription()  Returns the text description of the feed.    getLink()  Returns a URI to the HTML website containing the same or similar information as this feed (i.e. if the feed is from a blog, it should provide the blog's URI where the HTML version of the entries can be read).    getFeedLink()  Returns the URI of this feed, which may be the same as the URI used to import the feed. There are important cases where the feed link may differ because the source URI is being updated and is intended to be removed in the future.    getAuthors()  Returns an object of type  Zend\\Feed\\Reader\\Collection\\Author  which is an  ArrayObject  whose elements are each simple arrays containing any combination of the keys \"name\", \"email\" and \"uri\". Where irrelevant to the source data, some of these keys may be omitted.    getAuthor(integer $index = 0)  Returns either the first author known, or with the optional $index parameter any specific index on the array of authors as described above (returning  NULL  if an invalid index).    getDateCreated()  Returns the date on which this feed was created. Generally only applicable to Atom, where it represents the date the resource described by an Atom 1.0 document was created. The returned date will be a  DateTime  object.    getDateModified()  Returns the date on which this feed was last modified. The returned date will be a  DateTime  object.    getLastBuildDate()  Returns the date on which this feed was last built. The returned date will be a  DateTime  object. This is only supported by RSS; Atom feeds will always return  NULL .    getLanguage()  Returns the language of the feed (if defined) or simply the language noted in the XML document.    getGenerator()  Returns the generator of the feed, e.g. the software which generated it. This may differ between RSS and Atom since Atom defines a different notation.    getCopyright()  Returns any copyright notice associated with the feed.    getHubs()  Returns an array of all Hub Server URI endpoints which are advertised by the feed for use with the Pubsubhubbub Protocol, allowing subscriptions to the feed for real-time updates.    getCategories()  Returns a  Zend\\Feed\\Reader\\Collection\\Category  object containing the details of any categories associated with the overall feed. The supported fields include \"term\" (the machine readable category name), \"scheme\" (the categorisation scheme and domain for this category), and \"label\" (a HTML decoded human readable category name). Where any of the three fields are absent from the field, they are either set to the closest available alternative or, in the case of \"scheme\", set to  NULL .    getImage()  Returns an array containing data relating to any feed image or logo, or  NULL  if no image found. The resulting array may contain the following keys: uri, link, title, description, height, and width. Atom logos only contain a URI so the remaining metadata is drawn from RSS feeds only.     Given the variety of feeds in the wild, some of these methods will undoubtedly\nreturn  NULL  indicating the relevant information couldn't be located. Where\npossible,  Zend\\Feed\\Reader\\Reader  will fall back on alternative elements\nduring its search. For example, searching an RSS feed for a modification date is\nmore complicated than it looks. RSS 2.0 feeds should include a  <lastBuildDate> \ntag and/or a  <pubDate>  element. But what if it doesn't? Maybe this is an RSS\n1.0 feed? Perhaps it instead has an  <atom:updated>  element with identical\ninformation (Atom may be used to supplement RSS syntax)? Failing that, we\ncould simply look at the entries, pick the most recent, and use its  <pubDate> \nelement. Assuming it exists, that is. Many feeds also use Dublin Core 1.0 or 1.1 <dc:date>  elements for feeds and entries. Or we could find Atom lurking again.  The point is,  Zend\\Feed\\Reader\\Reader  was designed to know this. When you ask\nfor the modification date (or anything else), it will run off and search for all\nthese alternatives until it either gives up and returns  NULL , or finds an\nalternative that should have the right answer.  In addition to the above methods, all feed objects implement methods for\nretrieving the DOM and XPath objects for the current feeds as described\nearlier. Feed objects also implement the SPL Iterator and Countable\ninterfaces. The extended API is summarised below.",
            "title": "Feed Level API Methods"
        },
        {
            "location": "/reader/#extended-feed-api-methods",
            "text": "Method  Description      getDomDocument()  Returns the parent DOMDocument object for the entire source XML document.    getElement()  Returns the current feed level DOMElement object.    saveXml()  Returns a string containing an XML document of the entire feed element (this is not the original document, but a rebuilt version).    getXpath()  Returns the DOMXPath object used internally to run queries on the DOMDocument object (this includes core and extension namespaces pre-registered).    getXpathPrefix()  Returns the valid DOM path prefix prepended to all XPath queries matching the feed being queried.    getEncoding()  Returns the encoding of the source XML document (note: this cannot account for errors such as the server sending documents in a different encoding). Where not defined, the default UTF-8 encoding of Unicode is applied.    count()  Returns a count of the entries or items this feed contains (implements SPL  Countable  interface)    current()  Returns either the current entry (using the current index from  key() ).    key()  Returns the current entry index.    next()  Increments the entry index value by one.    rewind()  Resets the entry index to 0.    valid()  Checks that the current entry index is valid, i.e. it does not fall below 0 and does not exceed the number of entries existing.    getExtensions()  Returns an array of all extension objects loaded for the current feed (note: both feed-level and entry-level extensions exist, and only feed-level extensions are returned here). The array keys are of the form  {ExtensionName}_Feed .    getExtension(string $name)  Returns an extension object for the feed registered under the provided name. This allows more fine-grained access to extensions which may otherwise be hidden within the implementation of the standard API methods.    getType()  Returns a static class constant (e.g.   Zend\\Feed\\Reader\\Reader::TYPE_ATOM_03 , i.e. \"Atom 0.3\"), indicating exactly what kind of feed is being consumed.",
            "title": "Extended Feed API Methods"
        },
        {
            "location": "/reader/#retrieving-entryitem-information",
            "text": "Retrieving information for specific entries or items (depending on whether you\nspeak Atom or RSS) is identical to feed level data. Accessing entries is\nsimply a matter of iterating over a feed object or using the SPL  Iterator \ninterface feed objects implement, and calling the appropriate method on each.",
            "title": "Retrieving Entry/Item Information"
        },
        {
            "location": "/reader/#entry-api-methods",
            "text": "Method  Description      getId()  Returns a unique ID for the current entry.    getTitle()  Returns the title of the current entry.    getDescription()  Returns a description of the current entry.    getLink()  Returns a URI to the HTML version of the current entry.    getPermaLink()  Returns the permanent link to the current entry. In most cases, this is the same as using  getLink() .    getAuthors()  Returns an object of type  Zend\\Feed\\Reader\\Collection\\Author , which is an  ArrayObject  whose elements are each simple arrays containing any combination of the keys \"name\", \"email\" and \"uri\". Where irrelevant to the source data, some of these keys may be omitted.    getAuthor(integer $index = 0)  Returns either the first author known, or, with the optional  $index  parameter, any specific index on the array of Authors as described above (returning  NULL  if an invalid index).    getDateCreated()  Returns the date on which the current entry was created. Generally only applicable to Atom where it represents the date the resource described by an Atom 1.0 document was created.    getDateModified()  Returns the date on which the current entry was last modified.    getContent()  Returns the content of the current entry (this has any entities reversed if possible, assuming the content type is HTML). The description is returned if a separate content element does not exist.    getEnclosure()  Returns class object (stdClass) containing the value of all attributes from a multi-media  <enclosure>  element including as class attributes: url, length, type. In accordance with the RSS Best Practices Profile of the RSS Advisory Board, no support is offers for multiple enclosures since such support forms no part of the RSS specification.    getCommentCount()  Returns the number of comments made on this entry at the time the feed was last generated.    getCommentLink()  Returns a URI pointing to the HTML page where comments can be made on this entry.    getCommentFeedLink([string $type = \u2018atom'|'rss'])  Returns a URI pointing to a feed of the provided type containing all comments for this entry (type defaults to Atom/RSS depending on current feed type).    getCategories()  Returns a  Zend\\Feed\\Reader\\Collection\\Category  object containing the details of any categories associated with the entry. The supported fields include \"term\" (the machine readable category name), \"scheme\" (the categorisation scheme and domain for this category), and \"label\" (an HTML-decoded human readable category name). Where any of the three fields are absent from the field, they are either set to the closest available alternative or, in the case of \"scheme\", set to  NULL .     The extended API for entries is identical to that for feeds with the exception\nof the  Iterator  methods, which are not needed here.",
            "title": "Entry API Methods"
        },
        {
            "location": "/reader/#modified-vs-created-dates",
            "text": "There is often confusion over the concepts of  modified  and  created  dates.\nIn Atom, these are two clearly defined concepts (so knock yourself out) but in\nRSS they are vague. RSS 2.0 defines a single  <pubDate>  element which\ntypically refers to the date this entry was published, i.e.  a creation date of\nsorts. This is not always the case, and it may change with updates or not. As a\nresult, if you really want to check whether an entry has changed, don't rely on\nthe results of  getDateModified() . Instead, consider tracking the MD5 hash of\nthree other elements concatenated, e.g. using  getTitle() ,  getDescription() ,\nand  getContent() . If the entry was truly updated, this hash computation will\ngive a different result than previously saved hashes for the same entry. This\nis obviously content oriented, and will not assist in detecting changes to\nother relevant elements.  Atom feeds should not require such steps.  Further muddying the waters, dates in feeds may follow different standards.\nAtom and Dublin Core dates should follow ISO 8601, and RSS dates should\nfollow RFC 822 or RFC 2822 (which is also common). Date methods will throw an\nexception if  DateTime  cannot load the date string using one of the above\nstandards, or the PHP recognised possibilities for RSS dates.",
            "title": "Modified vs Created dates"
        },
        {
            "location": "/reader/#validation",
            "text": "The values returned from these methods are not validated. This means users\nmust perform validation on all retrieved data including the filtering of any\nHTML such as from  getContent()  before it is output from your application.\nRemember that most feeds come from external sources, and therefore the default\nassumption should be that they cannot be trusted.",
            "title": "Validation"
        },
        {
            "location": "/reader/#extended-entry-level-api-methods",
            "text": "Method  Description      getDomDocument()  Returns the parent DOMDocument object for the entire feed (not just the current entry).    getElement()  Returns the current entry level DOMElement object.    getXpath()  Returns the DOMXPath object used internally to run queries on the DOMDocument object (this includes core and extension namespaces pre-registered).    getXpathPrefix()  Returns the valid DOM path prefix prepended to all XPath queries matching the entry being queried.    getEncoding()  Returns the encoding of the source XML document (note: this cannot account for errors such as the server sending documents in a different encoding). The default encoding applied in the absence of any other is the UTF-8 encoding of Unicode.    getExtensions()  Returns an array of all extension objects loaded for the current entry (note: both feed-level and entry-level extensions exist, and only entry-level extensions are returned here). The array keys are in the form  {ExtensionName}Entry .    getExtension(string $name)  Returns an extension object for the entry registered under the provided name. This allows more fine-grained access to extensions which may otherwise be hidden within the implementation of the standard API methods.    getType()  Returns a static class constant (e.g.  Zend\\Feed\\Reader\\Reader::TYPE_ATOM_03 , i.e. \"Atom 0.3\") indicating exactly what kind of feed is being consumed.",
            "title": "Extended Entry Level API Methods"
        },
        {
            "location": "/reader/#extending-feed-and-entry-apis",
            "text": "Extending  Zend\\Feed\\Reader\\Reader  allows you to add methods at both the feed\nand entry level which cover the retrieval of information not already supported\nby  Zend\\Feed\\Reader\\Reader . Given the number of RSS and Atom extensions that\nexist, this is a good thing, since  Zend\\Feed\\Reader\\Reader  couldn't possibly\nadd everything.  There are two types of extensions possible, those which retrieve information\nfrom elements which are immediate children of the root element (e.g. <channel>  for RSS or  <feed>  for Atom), and those who retrieve information\nfrom child elements of an entry (e.g.  <item>  for RSS or  <entry>  for Atom).\nOn the filesystem, these are grouped as classes within a namespace based on the\nextension standard's name. For example, internally we have Zend\\Feed\\Reader\\Extension\\DublinCore\\Feed  and Zend\\Feed\\Reader\\Extension\\DublinCore\\Entry  classes which are two extensions\nimplementing Dublin Core 1.0 and 1.1 support.  Extensions are loaded into  Zend\\Feed\\Reader\\Reader  using an \"extension\nmanager\". Extension managers must implement  Zend\\Feed\\Reader\\ExtensionManagerInterface .\nThree implementations exist:   Zend\\Feed\\Reader\\StandaloneExtensionManager  is a hard-coded implementation\n  seeded with all feed and entry implementations. You can add simple extensions\n  from it using  add  and  remove  methods.  ExtensionPluginManager  is\n  recommended for more complex needs.  Zend\\Feed\\Reader\\ExtensionPluginManager  is a  Zend\\ServiceManager\\AbstractPluginManager \n  implementation,  Zend\\Feed\\Reader\\ExtensionManager ; as such, you can extend\n  it to add more extensions, use a  Zend\\ServiceManager\\ConfigInterface  instance\n  to inject it with more extensions, or use its public API for adding services\n  (e.g.,  setService() ,  setFactory() , etc.). This implementation  does not \n  implement  ExtensionManagerInterface , and must be used with  ExtensionManager .  Zend\\Feed\\Reader\\ExtensionManager  exists for legacy purposes; prior to 2.3,\n  this was an  AbstractPluginManager  implementation, and the only provided\n  extension manager. It now implements  ExtensionManagerInterface , and acts as\n  a decorator for  ExtensionPluginManager .   By default,  Zend\\Feed\\Reader\\Reader  composes a  StandaloneExtensionManager . You\ncan inject an alternate implementation using  Reader::setExtensionManager() :  $extensions = new Zend\\Feed\\Reader\\ExtensionPluginManager();\nZend\\Feed\\Reader\\Reader::setExtensionManager(\n    new ExtensionManager($extensions)\n);  The shipped implementations all provide the default extensions (so-called\n\"Core Extensions\") used internally by  Zend\\Feed\\Reader\\Reader . These\ninclude:     Extension  Description      DublinCore (Feed and Entry)  Implements support for Dublin Core Metadata Element Set 1.0 and 1.1.    Content (Entry only)  Implements support for Content 1.0.    Atom (Feed and Entry)  Implements support for Atom 0.3 and Atom 1.0.    Slash  Implements support for the Slash RSS 1.0 module.    WellFormedWeb  Implements support for the Well Formed Web CommentAPI 1.0.    Thread  Implements support for Atom Threading Extensions as described in RFC 4685.    Podcast  Implements support for the Podcast 1.0 DTD from Apple.     The core extensions are somewhat special since they are extremely common and\nmulti-faceted. For example, we have a core extension for Atom. Atom is\nimplemented as an extension (not just a base class) because it doubles as a\nvalid RSS module; you can insert Atom elements into RSS feeds.  I've even seen\nRDF feeds which use a lot of Atom in place of more common extensions like\nDublin Core.  The following is a list of non-Core extensions that are offered, but not registered\nby default. If you want to use them, you'll need to\ntell  Zend\\Feed\\Reader\\Reader  to load them in advance of importing a feed.\nAdditional non-Core extensions will be included in future iterations of the\ncomponent.     Extension  Description      Syndication  Implements Syndication 1.0 support for RSS feeds.    CreativeCommons  An RSS module that adds an element at the  <channel>  or  <item>  level that specifies which Creative Commons license applies.     Zend\\Feed\\Reader\\Reader  requires you to explicitly register non-Core\nextensions in order to expose their API to feed and entry objects.  Below, we\nregister the optional Syndication extension, and discover that it can be\ndirectly called from the entry API without any effort. (Note that\nextension names are case sensitive and use camelCasing for multiple terms.)  use Zend\\Feed\\Reader\\Reader;\n\nReader::registerExtension('Syndication');\n$feed = Reader::import('http://rss.slashdot.org/Slashdot/slashdot');\n$updatePeriod = $feed->getUpdatePeriod();  In the simple example above, we checked how frequently a feed is being updated\nusing the  getUpdatePeriod()  method. Since it's not part of Zend\\Feed\\Reader\\Reader 's core API, it could only be a method supported by\nthe newly registered Syndication extension.  As you can also notice, methods provided by extensions are accessible from the\nmain API using method overloading. As an alternative, you can also directly\naccess any extension object for a similar result as seen below.  use Zend\\Feed\\Reader\\Reader;\n\nReader::registerExtension('Syndication');\n$feed = Reader::import('http://rss.slashdot.org/Slashdot/slashdot');\n$syndication = $feed->getExtension('Syndication');\n$updatePeriod = $syndication->getUpdatePeriod();",
            "title": "Extending Feed and Entry APIs"
        },
        {
            "location": "/reader/#writing-zend92feed92reader-extensions",
            "text": "Inevitably, there will be times when the  Zend\\Feed\\Reader  API is just\nnot capable of getting something you need from a feed or entry. You can use the\nunderlying source objects, like DOMDocument, to get these by hand; however, there\nis a more reusable method available: you can write extensions supporting these new\nqueries.  As an example, let's take the case of a purely fictitious corporation named\nJungle Books. Jungle Books have been publishing a lot of reviews on books they\nsell (from external sources and customers), which are distributed as an RSS 2.0\nfeed. Their marketing department realises that web applications using this feed\ncannot currently figure out exactly what book is being reviewed. To make life\neasier for everyone, they determine that the geek department needs to extend\nRSS 2.0 to include a new element per entry supplying the ISBN-10 or ISBN-13\nnumber of the publication the entry concerns. They define the new  <isbn> \nelement quite simply with a standard name and namespace URI:   Name: JungleBooks 1.0  Namespace URI: http://example.com/junglebooks/rss/module/1.0/   A snippet of RSS containing this extension in practice could be something\nsimilar to:  <?xml version=\"1.0\" encoding=\"utf-8\" ?>\n<rss version=\"2.0\"\n   xmlns:content=\"http://purl.org/rss/1.0/modules/content/\"\n   xmlns:jungle=\"http://example.com/junglebooks/rss/module/1.0/\">\n<channel>\n    <title>Jungle Books Customer Reviews</title>\n    <link>http://example.com/junglebooks</link>\n    <description>Many book reviews!</description>\n    <pubDate>Fri, 26 Jun 2009 19:15:10 GMT</pubDate>\n    <jungle:dayPopular>\n        http://example.com/junglebooks/book/938\n    </jungle:dayPopular>\n    <item>\n        <title>Review Of Flatland: A Romance of Many Dimensions</title>\n        <link>http://example.com/junglebooks/review/987</link>\n        <author>Confused Physics Student</author>\n        <content:encoded>\n        A romantic square?!\n        </content:encoded>\n        <pubDate>Thu, 25 Jun 2009 20:03:28 -0700</pubDate>\n        <jungle:isbn>048627263X</jungle:isbn>\n    </item>\n</channel>\n</rss>  Implementing this new ISBN element as a simple entry level extension would\nrequire the following class (using your own namespace).  namespace My\\FeedReader\\Extension\\JungleBooks;\n\nuse Zend\\Feed\\Reader\\Extension\\AbstractEntry;\n\nclass Entry extends AbstractEntry\n{\n    public function getIsbn()\n    {\n        if (isset($this->data['isbn'])) {\n            return $this->data['isbn'];\n        }\n\n        $isbn = $this->xpath->evaluate(\n            'string(' . $this->getXpathPrefix() . '/jungle:isbn)'\n        );\n\n        if (! $isbn) {\n            $isbn = null;\n        }\n\n        $this->data['isbn'] = $isbn;\n        return $this->data['isbn'];\n    }\n\n    protected function registerNamespaces()\n    {\n        $this->xpath->registerNamespace(\n            'jungle',\n            'http://example.com/junglebooks/rss/module/1.0/'\n        );\n    }\n}  This extension creates a new method  getIsbn() , which runs an XPath query on\nthe current entry to extract the ISBN number enclosed by the  <jungle:isbn> \nelement. It can optionally store this to the internal non-persistent cache (no\nneed to keep querying the DOM if it's called again on the same entry). The\nvalue is returned to the caller. At the end we have a protected method (it's\nabstract, making it required by implementations) which registers the Jungle\nBooks namespace for their custom RSS module. While we call this an RSS module,\nthere's nothing to prevent the same element being used in Atom feeds; all\nextensions which use the prefix provided by  getXpathPrefix()  are actually\nneutral and work on RSS or Atom feeds with no extra code.  Since this extension is stored outside of zend-feed, you'll need to ensure your\napplication can autoload it. Once that's in place, you will also need to ensure\nyour extension manager knows about it, and then register the extension with Zend\\Feed\\Reader\\Reader .  The following example uses  Zend\\Feed\\Reader\\ExtensionPluginManager  to manage\nextensions, as it provides the ability to register new extensions without\nrequiring extension of the plugin manager itself (note that this example works\nwith ServiceManager v2, but not v3). To use it, first install\nzend-servicemanager:  $ composer require zendframework/zend-servicemanager  From there:  use My\\FeedReader\\Extension\\JungleBooks;\nuse Zend\\Feed\\Reader\\ExtensionManager;\nuse Zend\\Feed\\Reader\\ExtensionPluginManager;\nuse Zend\\Feed\\Reader\\Reader;\n\n$extensions = new ExtensionPluginManager();\n$extensions->setInvokableClass('JungleBooks\\Entry', JungleBooks\\Entry::class);\nReader::setExtensionManager(new ExtensionManager($extensions));\nReader::registerExtension('JungleBooks');\n\n$feed = Reader::import('http://example.com/junglebooks/rss');\n\n// ISBN for whatever book the first entry in the feed was concerned with\n$firstIsbn = $feed->current()->getIsbn();  Writing a feed extension is not much different. The example feed from earlier\nincluded an unmentioned  <jungle:dayPopular>  element which Jungle Books have\nadded to their standard to include a link to the day's most popular book (in\nterms of visitor traffic). Here's an extension which adds a getDaysPopularBookLink()  method to the feel level API.  namespace My\\FeedReader\\Extension\\JungleBooks;\n\nuse Zend\\Feed\\Reader\\Extension\\AbstractFeed;\n\nclass Feed extends AbstractFeed\n{\n    public function getDaysPopularBookLink()\n    {\n        if (isset($this->data['dayPopular'])) {\n            return $this->data['dayPopular'];\n        }\n\n        $dayPopular = $this->xpath->evaluate(\n            'string(' . $this->getXpathPrefix() . '/jungle:dayPopular)'\n        );\n\n        if (!$dayPopular) {\n            $dayPopular = null;\n        }\n\n        $this->data['dayPopular'] = $dayPopular;\n        return $this->data['dayPopular'];\n    }\n\n    protected function registerNamespaces()\n    {\n        $this->xpath->registerNamespace(\n            'jungle',\n            'http://example.com/junglebooks/rss/module/1.0/'\n        );\n    }\n}  Let's add to the previous example; we'll register the new class with the\nextension manager, and then demonstrate using the newly exposed method:  use My\\FeedReader\\Extension\\JungleBooks;\nuse Zend\\Feed\\Reader\\ExtensionManager;\nuse Zend\\Feed\\Reader\\ExtensionPluginManager;\nuse Zend\\Feed\\Reader\\Reader;\n\n$extensions = new ExtensionPluginManager();\n$extensions->setInvokableClass('JungleBooks\\Entry', JungleBooks\\Entry::class);\n$extensions->setInvokableClass('JungleBooks\\Feed', JungleBooks\\Feed::class);\nReader::setExtensionManager(new ExtensionManager($extensions));\nReader::registerExtension('JungleBooks');\n\n$feed = Reader::import('http://example.com/junglebooks/rss');\n\n// URI to the information page of the day's most popular book with visitors\n$daysPopularBookLink = $feed->getDaysPopularBookLink();  Going through these examples, you'll note that while we need to register the\nfeed and entry classes separately with the plugin manager, we don't register\nthem separately when registering the extension with the  Reader .  Extensions\nwithin the same standard may or may not include both a feed and entry class, so Zend\\Feed\\Reader\\Reader  only requires you to register the overall parent name,\ne.g.  JungleBooks, DublinCore, Slash. Internally, it can check at what level\nextensions exist and load them up if found. In our case, we have a complete\nextension now, spanning the classes  JungleBooks\\Feed  and  JungleBooks\\Entry .",
            "title": "Writing Zend\\Feed\\Reader Extensions"
        },
        {
            "location": "/http-clients/",
            "text": "HTTP Clients and zend-feed\n\n\nSeveral operations in zend-feed's Reader subcomponent require an HTTP client:\n\n\n\n\nimporting a feed\n\n\nfinding links in a feed\n\n\n\n\nIn order to allow developers a choice in HTTP clients, the subcomponent defines\nseveral interfaces and classes. Elsewhere in the documentation, we reference\nwhere an HTTP client may be used; this document details what constitutes an HTTP\nclient and its behavior, and some of the concrete classes available within the\ncomponent for implementing this behavior.\n\n\nClientInterface and HeaderAwareClientInterface\n\n\nFirst, we define two interfaces for clients,\n\nZend\\Feed\\Reader\\Http\\ClientInterface\n and \nHeaderAwareClientInterface\n:\n\n\nnamespace Zend\\Feed\\Reader\\Http;\n\ninterface ClientInterface\n{\n    /**\n     * Make a GET request to a given URL.\n     *\n     * @param string $url\n     * @return ResponseInterface\n     */\n    public function get($url);\n}\n\ninterface HeaderAwareClientInterface extends ClientInterface\n{\n    /**\n     * Make a GET request to a given URL.\n     *\n     * @param string $url\n     * @param array $headers\n     * @return ResponseInterface\n     */\n    public function get($url, array $headers = []);\n}\n\n\n\nThe first is header-agnostic, and assumes that the client will simply perform an\nHTTP GET request. The second allows providing headers to the client; typically,\nthese are used for HTTP caching headers. \n$headers\n must be in the following\nstructure:\n\n\n$headers = [\n    'X-Header-Name' => [\n        'header',\n        'values',\n    ],\n];\n\n\n\ni.e., each key is a header name, and each value is an array of values for that\nheader. If the header represents only a single value, it should be an array with\nthat value:\n\n\n$headers = [\n    'Accept' => [ 'application/rss+xml' ],\n];\n\n\n\nA call to \nget()\n should yield a \nresponse\n.\n\n\nResponseInterface and HeaderAwareResponseInterface\n\n\nResponses are modeled using \nZend\\Feed\\Reader\\Http\\ResponseInterface\n and\n\nHeaderAwareResponseInterface\n:\n\n\nnamespace Zend\\Feed\\Reader\\Http;\n\nclass ResponseInterface\n{\n    /**\n     * Retrieve the status code.\n     *\n     * @return int\n     */\n    public function getStatusCode();\n\n    /**\n     * Retrieve the response body contents.\n     *\n     * @return string\n     */\n    public function getBody();\n}\n\nclass HeaderAwareResponseInterface extends ResponseInterface\n{\n    /**\n     * Retrieve a named header line.\n     *\n     * Retrieve a header by name; all values MUST be concatenated to a single\n     * line. If no matching header is found, return the $default value.\n     *\n     * @param string $name\n     * @param null|string $default\n     * @return string\n    public function getHeaderLine($name, $default = null);\n}\n\n\n\nInternally, \nReader\n will typehint against \nClientInterface\n for the bulk of\noperations. In some cases, however, certain capabilities are only possible if\nthe response can provide headers (e.g., for caching); in such cases, it will\ncheck the instance against \nHeaderAwareResponseInterface\n, and only call\n\ngetHeaderLine()\n if it matches.\n\n\nResponse\n\n\nzend-feed ships with a generic \nResponseInterface\n implementation,\n\nZend\\Feed\\Http\\Response\n. It implements \nHeaderAwareResponseInterface\n, and\ndefines the following constructor:\n\n\nnamespace Zend\\Feed\\Reader\\Http;\n\nclass Response implements HeaderAwareResponseInterface\n{\n    /**\n     * Constructor\n     *\n     * @param int $statusCode Response status code\n     * @param string $body Response body\n     * @param array $headers Response headers, if available\n     */\n    public function __construct($statusCode, $body, array $headers = []);\n}\n\n\n\nPSR-7 Response\n\n\nPSR-7\n defines a set of HTTP message\ninterfaces, but not a client interface. To facilitate wrapping an HTTP client\nthat uses PSR-7 messages, we provide \nZend\\Feed\\Reader\\Psr7ResponseDecorator\n:\n\n\nnamespace Zend\\Feed\\Reader\\Http;\n\nuse Psr\\Http\\Message\\ResponseInterface as PsrResponseInterface;\n\nclass Psr7ResponseDecorator implements HeaderAwareResponseInterface\n{\n    /**\n     * @param PsrResponseInterface $response\n     */\n    public function __construct(PsrResponseInterface $response);\n\n    /**\n     * @return PsrResponseInterface\n     */\n    public function getDecoratedResponse();\n}\n\n\n\nClients can then take the PSR-7 response they receive, pass it to the decorator,\nand return the decorator.\n\n\nTo use the PSR-7 response, you will need to add the PSR-7 interfaces to your\napplication, if they are not already installed by the client of your choice:\n\n\n$ composer require psr/http-message\n\n\n\nzend-http\n\n\nWe also provide a zend-http client decorator,\n\nZend\\Feed\\Reader\\Http\\ZendHttpClientDecorator\n:\n\n\nnamespace Zend\\Feed\\Reader\\Http;\n\nuse Zend\\Http\\Client as HttpClient;\n\nclass ZendHttpClientDecorator implements HeaderAwareClientInterface\n{\n    /**\n     * @param HttpClient $client\n     */\n    public function __construct(HttpClient $client);\n\n    /**\n     * @return HttpClient\n     */\n    public function getDecoratedClient();\n}\n\n\n\nIts \nget()\n implementation returns a \nResponse\n instance seeded from the\nzend-http response returned, including status, body, and headers.\n\n\nzend-http is the default implementation assumed by \nZend\\Feed\\Reader\\Reader\n,\nbut \nis not installed by default\n. You may install it using composer:\n\n\n$ composer require zendframework/zend-http\n\n\n\nProviding a client to Reader\n\n\nBy default, \nZend\\Feed\\Reader\\Reader\n will lazy load a zend-http client. If you\nhave not installed zend-http, however, PHP will raise an error indicating the\nclass is not found!\n\n\nAs such, you have two options:\n\n\n\n\nInstall zend-http: \ncomposer require zendframework/zend-http\n.\n\n\nInject the \nReader\n with your own HTTP client.\n\n\n\n\nTo accomplish the second, you will need an implementation of\n\nZend\\Feed\\Reader\\Http\\ClientInterface\n or \nHeaderAwareClientInterface\n, and an\ninstance of that implementation. Once you do, you can use the static method\n\nsetHttpClient()\n to inject it.\n\n\nAs an example, let's say you've created a PSR-7-based implementation named\n\nMy\\Http\\Psr7FeedClient\n. You could then do the following:\n\n\nuse My\\Http\\Psr7FeedClient;\nuse Zend\\Feed\\Reader\\Reader;\n\nReader::setHttpClient(new Psr7FeedClient());\n\n\n\nYour client will then be used for all \nimport()\n and \nfindFeedLinks()\n\noperations.",
            "title": "HTTP Clients"
        },
        {
            "location": "/http-clients/#http-clients-and-zend-feed",
            "text": "Several operations in zend-feed's Reader subcomponent require an HTTP client:   importing a feed  finding links in a feed   In order to allow developers a choice in HTTP clients, the subcomponent defines\nseveral interfaces and classes. Elsewhere in the documentation, we reference\nwhere an HTTP client may be used; this document details what constitutes an HTTP\nclient and its behavior, and some of the concrete classes available within the\ncomponent for implementing this behavior.",
            "title": "HTTP Clients and zend-feed"
        },
        {
            "location": "/http-clients/#clientinterface-and-headerawareclientinterface",
            "text": "First, we define two interfaces for clients, Zend\\Feed\\Reader\\Http\\ClientInterface  and  HeaderAwareClientInterface :  namespace Zend\\Feed\\Reader\\Http;\n\ninterface ClientInterface\n{\n    /**\n     * Make a GET request to a given URL.\n     *\n     * @param string $url\n     * @return ResponseInterface\n     */\n    public function get($url);\n}\n\ninterface HeaderAwareClientInterface extends ClientInterface\n{\n    /**\n     * Make a GET request to a given URL.\n     *\n     * @param string $url\n     * @param array $headers\n     * @return ResponseInterface\n     */\n    public function get($url, array $headers = []);\n}  The first is header-agnostic, and assumes that the client will simply perform an\nHTTP GET request. The second allows providing headers to the client; typically,\nthese are used for HTTP caching headers.  $headers  must be in the following\nstructure:  $headers = [\n    'X-Header-Name' => [\n        'header',\n        'values',\n    ],\n];  i.e., each key is a header name, and each value is an array of values for that\nheader. If the header represents only a single value, it should be an array with\nthat value:  $headers = [\n    'Accept' => [ 'application/rss+xml' ],\n];  A call to  get()  should yield a  response .",
            "title": "ClientInterface and HeaderAwareClientInterface"
        },
        {
            "location": "/http-clients/#responseinterface-and-headerawareresponseinterface",
            "text": "Responses are modeled using  Zend\\Feed\\Reader\\Http\\ResponseInterface  and HeaderAwareResponseInterface :  namespace Zend\\Feed\\Reader\\Http;\n\nclass ResponseInterface\n{\n    /**\n     * Retrieve the status code.\n     *\n     * @return int\n     */\n    public function getStatusCode();\n\n    /**\n     * Retrieve the response body contents.\n     *\n     * @return string\n     */\n    public function getBody();\n}\n\nclass HeaderAwareResponseInterface extends ResponseInterface\n{\n    /**\n     * Retrieve a named header line.\n     *\n     * Retrieve a header by name; all values MUST be concatenated to a single\n     * line. If no matching header is found, return the $default value.\n     *\n     * @param string $name\n     * @param null|string $default\n     * @return string\n    public function getHeaderLine($name, $default = null);\n}  Internally,  Reader  will typehint against  ClientInterface  for the bulk of\noperations. In some cases, however, certain capabilities are only possible if\nthe response can provide headers (e.g., for caching); in such cases, it will\ncheck the instance against  HeaderAwareResponseInterface , and only call getHeaderLine()  if it matches.",
            "title": "ResponseInterface and HeaderAwareResponseInterface"
        },
        {
            "location": "/http-clients/#response",
            "text": "zend-feed ships with a generic  ResponseInterface  implementation, Zend\\Feed\\Http\\Response . It implements  HeaderAwareResponseInterface , and\ndefines the following constructor:  namespace Zend\\Feed\\Reader\\Http;\n\nclass Response implements HeaderAwareResponseInterface\n{\n    /**\n     * Constructor\n     *\n     * @param int $statusCode Response status code\n     * @param string $body Response body\n     * @param array $headers Response headers, if available\n     */\n    public function __construct($statusCode, $body, array $headers = []);\n}",
            "title": "Response"
        },
        {
            "location": "/http-clients/#psr-7-response",
            "text": "PSR-7  defines a set of HTTP message\ninterfaces, but not a client interface. To facilitate wrapping an HTTP client\nthat uses PSR-7 messages, we provide  Zend\\Feed\\Reader\\Psr7ResponseDecorator :  namespace Zend\\Feed\\Reader\\Http;\n\nuse Psr\\Http\\Message\\ResponseInterface as PsrResponseInterface;\n\nclass Psr7ResponseDecorator implements HeaderAwareResponseInterface\n{\n    /**\n     * @param PsrResponseInterface $response\n     */\n    public function __construct(PsrResponseInterface $response);\n\n    /**\n     * @return PsrResponseInterface\n     */\n    public function getDecoratedResponse();\n}  Clients can then take the PSR-7 response they receive, pass it to the decorator,\nand return the decorator.  To use the PSR-7 response, you will need to add the PSR-7 interfaces to your\napplication, if they are not already installed by the client of your choice:  $ composer require psr/http-message",
            "title": "PSR-7 Response"
        },
        {
            "location": "/http-clients/#zend-http",
            "text": "We also provide a zend-http client decorator, Zend\\Feed\\Reader\\Http\\ZendHttpClientDecorator :  namespace Zend\\Feed\\Reader\\Http;\n\nuse Zend\\Http\\Client as HttpClient;\n\nclass ZendHttpClientDecorator implements HeaderAwareClientInterface\n{\n    /**\n     * @param HttpClient $client\n     */\n    public function __construct(HttpClient $client);\n\n    /**\n     * @return HttpClient\n     */\n    public function getDecoratedClient();\n}  Its  get()  implementation returns a  Response  instance seeded from the\nzend-http response returned, including status, body, and headers.  zend-http is the default implementation assumed by  Zend\\Feed\\Reader\\Reader ,\nbut  is not installed by default . You may install it using composer:  $ composer require zendframework/zend-http",
            "title": "zend-http"
        },
        {
            "location": "/http-clients/#providing-a-client-to-reader",
            "text": "By default,  Zend\\Feed\\Reader\\Reader  will lazy load a zend-http client. If you\nhave not installed zend-http, however, PHP will raise an error indicating the\nclass is not found!  As such, you have two options:   Install zend-http:  composer require zendframework/zend-http .  Inject the  Reader  with your own HTTP client.   To accomplish the second, you will need an implementation of Zend\\Feed\\Reader\\Http\\ClientInterface  or  HeaderAwareClientInterface , and an\ninstance of that implementation. Once you do, you can use the static method setHttpClient()  to inject it.  As an example, let's say you've created a PSR-7-based implementation named My\\Http\\Psr7FeedClient . You could then do the following:  use My\\Http\\Psr7FeedClient;\nuse Zend\\Feed\\Reader\\Reader;\n\nReader::setHttpClient(new Psr7FeedClient());  Your client will then be used for all  import()  and  findFeedLinks() \noperations.",
            "title": "Providing a client to Reader"
        },
        {
            "location": "/psr7-clients/",
            "text": "Using PSR-7 Clients\n\n\nAs noted in the previous section, you can \nsubstitute your own HTTP client by implementing the ClientInterface\n.\nIn this section, we'll demonstrate doing so in order to use a client that is\n\nPSR-7\n-capable.\n\n\nResponses\n\n\nzend-feed provides a facility to assist with generating a\n\nZend\\Feed\\Reader\\Response\n from a PSR-7 \nResponseInterface\n via\n\nZend\\Feed\\Reader\\Http\\Psr7ResponseDecorator\n. As such, if you have a\nPSR-7-capable client, you can pass the response to this decorator, and\nimmediately return it from your custom client:\n\n\nreturn new Psr7ResponseDecorator($psr7Response);\n\n\n\nWe'll do this with our PSR-7 client.\n\n\nGuzzle\n\n\nGuzzle\n is arguably the most popular HTTP\nclient library for PHP, and fully supports PSR-7 since version 5. Let's install\nit:\n\n\n$ composer require guzzlehttp/guzzle\n\n\n\nWe'll use the \nGuzzleHttp\\Client\n to make our requests to feeds.\n\n\nCreating a client\n\n\nFrom here, we'll create our client. To do this, we'll create a class that:\n\n\n\n\nimplements \nZend\\Feed\\Reader\\Http\\ClientInterface\n\n\naccepts a \nGuzzleHttp\\ClientInterface\n to its constructor\n\n\nuses the Guzzle client to make the request\n\n\nreturns a zend-feed response decorating the actual PSR-7 response\n\n\n\n\nThe code looks like this:\n\n\nuse GuzzleHttp\\Client;\nuse GuzzleHttp\\ClientInterface as GuzzleClientInterface;\nuse Zend\\Feed\\Reader\\Http\\ClientInterface as FeedReaderHttpClientInterface;\nuse Zend\\Feed\\Reader\\Http\\Psr7ResponseDecorator;\n\nclass GuzzleClient implements FeedReaderHttpClientInterface\n{\n    /**\n     * @var GuzzleClientInterface\n     */\n    private $client;\n\n    /**\n     * @param GuzzleClientInterface|null $client\n     */\n    public function __construct(GuzzleClientInterface $client = null)\n    {\n        $this->client = $client ?: new Client();\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function get($uri)\n    {\n        return new Psr7ResponseDecorator(\n            $this->client->request('GET', $uri)\n        );\n    }\n}\n\n\n\nUsing the client\n\n\nIn order to use our new client, we need to tell \nZend\\Feed\\Reader\\Reader\n about\nit:\n\n\nZend\\Feed\\Reader\\Reader::setHttpClient(new GuzzleClient());\n\n\n\nFrom this point forward, this custom client will be used to retrieve feeds.\n\n\nReferences\n\n\nThis chapter is based on \na blog post by Stefan Gehrig\n.",
            "title": "Using PSR-7 Clients"
        },
        {
            "location": "/psr7-clients/#using-psr-7-clients",
            "text": "As noted in the previous section, you can  substitute your own HTTP client by implementing the ClientInterface .\nIn this section, we'll demonstrate doing so in order to use a client that is PSR-7 -capable.",
            "title": "Using PSR-7 Clients"
        },
        {
            "location": "/psr7-clients/#responses",
            "text": "zend-feed provides a facility to assist with generating a Zend\\Feed\\Reader\\Response  from a PSR-7  ResponseInterface  via Zend\\Feed\\Reader\\Http\\Psr7ResponseDecorator . As such, if you have a\nPSR-7-capable client, you can pass the response to this decorator, and\nimmediately return it from your custom client:  return new Psr7ResponseDecorator($psr7Response);  We'll do this with our PSR-7 client.",
            "title": "Responses"
        },
        {
            "location": "/psr7-clients/#guzzle",
            "text": "Guzzle  is arguably the most popular HTTP\nclient library for PHP, and fully supports PSR-7 since version 5. Let's install\nit:  $ composer require guzzlehttp/guzzle  We'll use the  GuzzleHttp\\Client  to make our requests to feeds.",
            "title": "Guzzle"
        },
        {
            "location": "/psr7-clients/#creating-a-client",
            "text": "From here, we'll create our client. To do this, we'll create a class that:   implements  Zend\\Feed\\Reader\\Http\\ClientInterface  accepts a  GuzzleHttp\\ClientInterface  to its constructor  uses the Guzzle client to make the request  returns a zend-feed response decorating the actual PSR-7 response   The code looks like this:  use GuzzleHttp\\Client;\nuse GuzzleHttp\\ClientInterface as GuzzleClientInterface;\nuse Zend\\Feed\\Reader\\Http\\ClientInterface as FeedReaderHttpClientInterface;\nuse Zend\\Feed\\Reader\\Http\\Psr7ResponseDecorator;\n\nclass GuzzleClient implements FeedReaderHttpClientInterface\n{\n    /**\n     * @var GuzzleClientInterface\n     */\n    private $client;\n\n    /**\n     * @param GuzzleClientInterface|null $client\n     */\n    public function __construct(GuzzleClientInterface $client = null)\n    {\n        $this->client = $client ?: new Client();\n    }\n\n    /**\n     * {@inheritdoc}\n     */\n    public function get($uri)\n    {\n        return new Psr7ResponseDecorator(\n            $this->client->request('GET', $uri)\n        );\n    }\n}",
            "title": "Creating a client"
        },
        {
            "location": "/psr7-clients/#using-the-client",
            "text": "In order to use our new client, we need to tell  Zend\\Feed\\Reader\\Reader  about\nit:  Zend\\Feed\\Reader\\Reader::setHttpClient(new GuzzleClient());  From this point forward, this custom client will be used to retrieve feeds.",
            "title": "Using the client"
        },
        {
            "location": "/psr7-clients/#references",
            "text": "This chapter is based on  a blog post by Stefan Gehrig .",
            "title": "References"
        },
        {
            "location": "/importing/",
            "text": "Importing Feeds\n\n\nZend\\Feed\n enables developers to retrieve feeds via \nZend\\Feader\\Reader\n. If\nyou know the URI of a feed, use the \nZend\\Feed\\Reader\\Reader::import()\n method\nto consume it:\n\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://feeds.example.com/feedName');\n\n\n\n\n\nImporting requires an HTTP client\n\n\nTo import a feed, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.\n\n\n\n\nYou can also use \nZend\\Feed\\Reader\\Reader\n to fetch the contents of a feed from\na file or the contents of a PHP string variable:\n\n\n// importing a feed from a text file\n$feedFromFile = Zend\\Feed\\Reader\\Reader::importFile('feed.xml');\n\n// importing a feed from a PHP string variable\n$feedFromPHP = Zend\\Feed\\Reader\\Reader::importString($feedString);\n\n\n\nIn each of the examples above, an object of a class that extends\n\nZend\\Feed\\Reader\\Feed\\AbstractFeed\n is returned upon success, depending on the\ntype of the feed. If an RSS feed were retrieved via one of the import methods\nabove, then a \nZend\\Feed\\Reader\\Feed\\Rss\n object would be returned. On the other\nhand, if an Atom feed were imported, then a \nZend\\Feed\\Reader\\Feed\\Atom\n object\nis returned. The import methods will also throw a\n\nZend\\Feed\\Exception\\Reader\\RuntimeException\n object upon failure, such as an\nunreadable or malformed feed.\n\n\nDumping the contents of a feed\n\n\nTo dump the contents of a \nZend\\Feed\\Reader\\Feed\\AbstractFeed\n instance, you may\nuse the \nsaveXml()\n method.\n\n\nassert($feed instanceof Zend\\Feed\\Reader\\Feed\\AbstractFeed);\n\n// dump the feed to standard output\nprint $feed->saveXml();",
            "title": "Importing Feeds"
        },
        {
            "location": "/importing/#importing-feeds",
            "text": "Zend\\Feed  enables developers to retrieve feeds via  Zend\\Feader\\Reader . If\nyou know the URI of a feed, use the  Zend\\Feed\\Reader\\Reader::import()  method\nto consume it:  $feed = Zend\\Feed\\Reader\\Reader::import('http://feeds.example.com/feedName');",
            "title": "Importing Feeds"
        },
        {
            "location": "/importing/#importing-requires-an-http-client",
            "text": "To import a feed, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .   You can also use  Zend\\Feed\\Reader\\Reader  to fetch the contents of a feed from\na file or the contents of a PHP string variable:  // importing a feed from a text file\n$feedFromFile = Zend\\Feed\\Reader\\Reader::importFile('feed.xml');\n\n// importing a feed from a PHP string variable\n$feedFromPHP = Zend\\Feed\\Reader\\Reader::importString($feedString);  In each of the examples above, an object of a class that extends Zend\\Feed\\Reader\\Feed\\AbstractFeed  is returned upon success, depending on the\ntype of the feed. If an RSS feed were retrieved via one of the import methods\nabove, then a  Zend\\Feed\\Reader\\Feed\\Rss  object would be returned. On the other\nhand, if an Atom feed were imported, then a  Zend\\Feed\\Reader\\Feed\\Atom  object\nis returned. The import methods will also throw a Zend\\Feed\\Exception\\Reader\\RuntimeException  object upon failure, such as an\nunreadable or malformed feed.",
            "title": "Importing requires an HTTP client"
        },
        {
            "location": "/importing/#dumping-the-contents-of-a-feed",
            "text": "To dump the contents of a  Zend\\Feed\\Reader\\Feed\\AbstractFeed  instance, you may\nuse the  saveXml()  method.  assert($feed instanceof Zend\\Feed\\Reader\\Feed\\AbstractFeed);\n\n// dump the feed to standard output\nprint $feed->saveXml();",
            "title": "Dumping the contents of a feed"
        },
        {
            "location": "/find-feeds/",
            "text": "Feed Discovery from Web Pages\n\n\nWeb pages often contain \n<link>\n tags that refer to feeds with content relevant\nto the particular page. \nZend\\Feed\\Reader\\Reader\n enables you to retrieve all\nfeeds referenced by a web page with one method call:\n\n\n$feedLinks = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.example.com/news.html');\n\n\n\n\n\nFinding feed links requires an HTTP client\n\n\nTo find feed links, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.\n\n\n\n\nHere the \nfindFeedLinks()\n method returns a \nZend\\Feed\\Reader\\FeedSet\n object,\nwhich is in turn a collection of other \nZend\\Feed\\Reader\\FeedSet\n objects, each\nreferenced by \n<link>\n tags on the \nnews.html\n web page.\n\nZend\\Feed\\Reader\\Reader\n will throw a\n\nZend\\Feed\\Reader\\Exception\\RuntimeException\n upon failure, such as an HTTP\n404 response code or a malformed feed.\n\n\nYou can examine all feed links located by iterating across the collection:\n\n\n$rssFeed = null;\n$feedLinks = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.example.com/news.html');\nforeach ($feedLinks as $link) {\n    if (stripos($link['type'], 'application/rss+xml') !== false) {\n        $rssFeed = $link['href'];\n        break;\n}\n\n\n\nEach \nZend\\Feed\\Reader\\FeedSet\n object will expose the \nrel\n, \nhref\n, \ntype\n,\nand \ntitle\n properties of detected links for all RSS, Atom, or RDF feeds. You\ncan always select the first encountered link of each type by using a shortcut:\nthe first encountered link of a given type is assigned to a property named after\nthe feed type.\n\n\n$rssFeed = null;\n$feedLinks = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.example.com/news.html');\n$firstAtomFeed = $feedLinks->atom;",
            "title": "Feed Discovery"
        },
        {
            "location": "/find-feeds/#feed-discovery-from-web-pages",
            "text": "Web pages often contain  <link>  tags that refer to feeds with content relevant\nto the particular page.  Zend\\Feed\\Reader\\Reader  enables you to retrieve all\nfeeds referenced by a web page with one method call:  $feedLinks = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.example.com/news.html');",
            "title": "Feed Discovery from Web Pages"
        },
        {
            "location": "/find-feeds/#finding-feed-links-requires-an-http-client",
            "text": "To find feed links, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .   Here the  findFeedLinks()  method returns a  Zend\\Feed\\Reader\\FeedSet  object,\nwhich is in turn a collection of other  Zend\\Feed\\Reader\\FeedSet  objects, each\nreferenced by  <link>  tags on the  news.html  web page. Zend\\Feed\\Reader\\Reader  will throw a Zend\\Feed\\Reader\\Exception\\RuntimeException  upon failure, such as an HTTP\n404 response code or a malformed feed.  You can examine all feed links located by iterating across the collection:  $rssFeed = null;\n$feedLinks = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.example.com/news.html');\nforeach ($feedLinks as $link) {\n    if (stripos($link['type'], 'application/rss+xml') !== false) {\n        $rssFeed = $link['href'];\n        break;\n}  Each  Zend\\Feed\\Reader\\FeedSet  object will expose the  rel ,  href ,  type ,\nand  title  properties of detected links for all RSS, Atom, or RDF feeds. You\ncan always select the first encountered link of each type by using a shortcut:\nthe first encountered link of a given type is assigned to a property named after\nthe feed type.  $rssFeed = null;\n$feedLinks = Zend\\Feed\\Reader\\Reader::findFeedLinks('http://www.example.com/news.html');\n$firstAtomFeed = $feedLinks->atom;",
            "title": "Finding feed links requires an HTTP client"
        },
        {
            "location": "/consuming-rss/",
            "text": "Consuming RSS Feeds\n\n\nReading a feed\n\n\nTo read an RSS feed, pass its URL to \nZend\\Feed\\Reader\\Reader::import()\n:\n\n\n$channel = Zend\\Feed\\Reader\\Reader::import('http://rss.example.com/channelName');\n\n\n\n\n\nImporting requires an HTTP client\n\n\nTo import a feed, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.\n\n\n\n\nIf any errors occur fetching the feed, a\n\nZend\\Feed\\Reader\\Exception\\RuntimeException\n will be thrown.\n\n\nGet properties\n\n\nOnce you have a feed object, you can access any of the standard RSS channel\nproperties via the various instance getter methods:\n\n\necho $channel->getTitle();\necho $channel->getAuthor();\n// etc.\n\n\n\nIf channel properties have attributes, the getter method will return a key/value\npair, where the key is the attribute name, and the value is the attribute value.\n\n\n$author = $channel->getAuthor();\necho $author['name'];\n\n\n\nMost commonly, you'll want to loop through the feed and do something with its\nentries.  \nZend\\Feed\\Reader\\Feed\\Rss\n internally converts all entries to a\n\nZend\\Feed\\Reader\\Entry\\Rss\n instance. Entry properties, similarly to channel\nproperties, can be accessed via getter methods, such as \ngetTitle\n,\n\ngetDescription\n, etc.\n\n\nAn example of printing all titles of articles in a channel is:\n\n\nforeach ($channel as $item) {\n    echo $item->getTitle() . \"\\n\";\n}\n\n\n\nIf you are not familiar with RSS, here are the standard elements you can expect\nto be available in an RSS channel and in individual RSS items (entries).\n\n\nRequired channel elements:\n\n\n\n\ntitle\n: The name of the channel.\n\n\nlink\n: The URL of the web site corresponding to the channel.\n\n\ndescription\n: A sentence (or more) describing the channel.\n\n\n\n\nCommon optional channel elements:\n\n\n\n\npubDate\n: The publication date of this set of content, in RFC 822 date\n  format.\n\n\nlanguage\n: The language the channel is written in.\n\n\ncategory\n: One or more (specified by multiple tags) categories the channel\n  belongs to.\n\n\n\n\nRSS \n<item>\n elements do not have any strictly required elements. However,\neither \ntitle\n or \ndescription\n must be present.\n\n\nCommon item elements:\n\n\n\n\ntitle\n: The title of the item.\n\n\nlink\n: The URL of the item.\n\n\ndescription\n: A synopsis of the item.\n\n\nauthor\n: The author's email address.\n\n\ncategory\n: One more categories that the item belongs to.\n\n\ncomments\n: URL of comments relating to this item.\n\n\npubDate\n: The date the item was published, in RFC 822 date format.\n\n\n\n\nIn your code you can always test to see if an element is non-empty by calling\nthe getter:\n\n\nif ($item->getPropname()) {\n    // ... proceed.\n}\n\n\n\nWhere relevant, \nZend\\Feed\n supports a number of common RSS extensions including\nDublin Core, Atom (inside RSS); the Content, Slash, Syndication,\nSyndication/Thread extensions; as well as several others.\n\n\nPlease see the official \nRSS 2.0 specification\n\nfor further information.",
            "title": "Consuming RSS Feeds"
        },
        {
            "location": "/consuming-rss/#consuming-rss-feeds",
            "text": "",
            "title": "Consuming RSS Feeds"
        },
        {
            "location": "/consuming-rss/#reading-a-feed",
            "text": "To read an RSS feed, pass its URL to  Zend\\Feed\\Reader\\Reader::import() :  $channel = Zend\\Feed\\Reader\\Reader::import('http://rss.example.com/channelName');",
            "title": "Reading a feed"
        },
        {
            "location": "/consuming-rss/#importing-requires-an-http-client",
            "text": "To import a feed, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .   If any errors occur fetching the feed, a Zend\\Feed\\Reader\\Exception\\RuntimeException  will be thrown.",
            "title": "Importing requires an HTTP client"
        },
        {
            "location": "/consuming-rss/#get-properties",
            "text": "Once you have a feed object, you can access any of the standard RSS channel\nproperties via the various instance getter methods:  echo $channel->getTitle();\necho $channel->getAuthor();\n// etc.  If channel properties have attributes, the getter method will return a key/value\npair, where the key is the attribute name, and the value is the attribute value.  $author = $channel->getAuthor();\necho $author['name'];  Most commonly, you'll want to loop through the feed and do something with its\nentries.   Zend\\Feed\\Reader\\Feed\\Rss  internally converts all entries to a Zend\\Feed\\Reader\\Entry\\Rss  instance. Entry properties, similarly to channel\nproperties, can be accessed via getter methods, such as  getTitle , getDescription , etc.  An example of printing all titles of articles in a channel is:  foreach ($channel as $item) {\n    echo $item->getTitle() . \"\\n\";\n}  If you are not familiar with RSS, here are the standard elements you can expect\nto be available in an RSS channel and in individual RSS items (entries).  Required channel elements:   title : The name of the channel.  link : The URL of the web site corresponding to the channel.  description : A sentence (or more) describing the channel.   Common optional channel elements:   pubDate : The publication date of this set of content, in RFC 822 date\n  format.  language : The language the channel is written in.  category : One or more (specified by multiple tags) categories the channel\n  belongs to.   RSS  <item>  elements do not have any strictly required elements. However,\neither  title  or  description  must be present.  Common item elements:   title : The title of the item.  link : The URL of the item.  description : A synopsis of the item.  author : The author's email address.  category : One more categories that the item belongs to.  comments : URL of comments relating to this item.  pubDate : The date the item was published, in RFC 822 date format.   In your code you can always test to see if an element is non-empty by calling\nthe getter:  if ($item->getPropname()) {\n    // ... proceed.\n}  Where relevant,  Zend\\Feed  supports a number of common RSS extensions including\nDublin Core, Atom (inside RSS); the Content, Slash, Syndication,\nSyndication/Thread extensions; as well as several others.  Please see the official  RSS 2.0 specification \nfor further information.",
            "title": "Get properties"
        },
        {
            "location": "/consuming-atom/",
            "text": "Consuming Atom Feeds\n\n\nZend\\Feed\\Reader\\Feed\\Atom\n is used in much the same way as\n\nZend\\Feed\\Reader\\Feed\\Rss\n. It provides the same access to feed-level\nproperties and iteration over entries in the feed. The main difference is in the\nstructure of the Atom protocol itself. Atom is a successor to RSS; it is a\nmore generalized protocol and it is designed to deal more easily with feeds that\nprovide their full content inside the feed, splitting RSS' \ndescription\n tag\ninto two elements, \nsummary\n and \ncontent\n, for that purpose.\n\n\nBasic Use of an Atom Feed\n\n\nRead an Atom feed and print the \ntitle\n and \nsummary\n of each entry:\n\n\n$feed = Zend\\Feed\\Reader\\Reader::import('http://atom.example.com/feed/');\necho 'The feed contains ' . $feed->count() . ' entries.' . \"\\n\\n\";\nforeach ($feed as $entry) {\n    echo 'Title: ' . $entry->getTitle() . \"\\n\";\n    echo 'Description: ' . $entry->getDescription() . \"\\n\";\n    echo 'URL: ' . $entry->getLink() . \"\\n\\n\";\n}\n\n\n\n\n\nImporting requires an HTTP client\n\n\nTo import a feed, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.\n\n\n\n\nIn an Atom feed, you can expect to find the following feed properties:\n\n\n\n\ntitle\n: The feed's title, same as RSS' channel title.\n\n\nid\n: Every feed and entry in Atom has a unique identifier.\n\n\nlink\n: Feeds can have multiple links, which are distinguished by a \ntype\n\n  attribute. The equivalent to RSS's channel link would be \ntype=\"text/html\"\n.\n  If the link is to an alternate version of the same content that's in the feed,\n  it would have a \nrel=\"alternate\"\n attribute.\n\n\nsubtitle\n: The feed's description, equivalent to RSS' channel description.\n\n\nauthor\n: The feed's author, with \nname\n and \nemail\n sub-tags.\n\n\n\n\nAtom entries commonly have the following properties:\n\n\n\n\nid\n: The entry's unique identifier.\n\n\ntitle\n: The entry's title, same as RSS item titles.\n\n\nlink\n: A link to another format or an alternate view of this entry.\n   The link property of an atom entry typically has an \nhref\n attribute.\n\n\nsummary\n: A summary of this entry's content.\n\n\ncontent\n: The full content of the entry; can be skipped if the feed just\n   contains summaries.\n\n\nauthor\n: with \nname\n and \nemail\n sub-tags like feeds have.\n\n\npublished\n: the date the entry was published, in RFC 3339 format.\n\n\nupdated\n: the date the entry was last updated, in RFC 3339 format.\n\n\n\n\nWhere relevant, \nZend\\Feed\n supports a number of common RSS extensions including\nDublin Core; Content, Slash, Syndication, and Syndication/Thread; and several\nothers in common use on blogs.\n\n\nFor more information on Atom and plenty of resources, see\n\nhttp://www.atomenabled.org/\n.",
            "title": "Consuming Atom Feeds"
        },
        {
            "location": "/consuming-atom/#consuming-atom-feeds",
            "text": "Zend\\Feed\\Reader\\Feed\\Atom  is used in much the same way as Zend\\Feed\\Reader\\Feed\\Rss . It provides the same access to feed-level\nproperties and iteration over entries in the feed. The main difference is in the\nstructure of the Atom protocol itself. Atom is a successor to RSS; it is a\nmore generalized protocol and it is designed to deal more easily with feeds that\nprovide their full content inside the feed, splitting RSS'  description  tag\ninto two elements,  summary  and  content , for that purpose.",
            "title": "Consuming Atom Feeds"
        },
        {
            "location": "/consuming-atom/#basic-use-of-an-atom-feed",
            "text": "Read an Atom feed and print the  title  and  summary  of each entry:  $feed = Zend\\Feed\\Reader\\Reader::import('http://atom.example.com/feed/');\necho 'The feed contains ' . $feed->count() . ' entries.' . \"\\n\\n\";\nforeach ($feed as $entry) {\n    echo 'Title: ' . $entry->getTitle() . \"\\n\";\n    echo 'Description: ' . $entry->getDescription() . \"\\n\";\n    echo 'URL: ' . $entry->getLink() . \"\\n\\n\";\n}",
            "title": "Basic Use of an Atom Feed"
        },
        {
            "location": "/consuming-atom/#importing-requires-an-http-client",
            "text": "To import a feed, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .   In an Atom feed, you can expect to find the following feed properties:   title : The feed's title, same as RSS' channel title.  id : Every feed and entry in Atom has a unique identifier.  link : Feeds can have multiple links, which are distinguished by a  type \n  attribute. The equivalent to RSS's channel link would be  type=\"text/html\" .\n  If the link is to an alternate version of the same content that's in the feed,\n  it would have a  rel=\"alternate\"  attribute.  subtitle : The feed's description, equivalent to RSS' channel description.  author : The feed's author, with  name  and  email  sub-tags.   Atom entries commonly have the following properties:   id : The entry's unique identifier.  title : The entry's title, same as RSS item titles.  link : A link to another format or an alternate view of this entry.\n   The link property of an atom entry typically has an  href  attribute.  summary : A summary of this entry's content.  content : The full content of the entry; can be skipped if the feed just\n   contains summaries.  author : with  name  and  email  sub-tags like feeds have.  published : the date the entry was published, in RFC 3339 format.  updated : the date the entry was last updated, in RFC 3339 format.   Where relevant,  Zend\\Feed  supports a number of common RSS extensions including\nDublin Core; Content, Slash, Syndication, and Syndication/Thread; and several\nothers in common use on blogs.  For more information on Atom and plenty of resources, see http://www.atomenabled.org/ .",
            "title": "Importing requires an HTTP client"
        },
        {
            "location": "/consuming-atom-entry/",
            "text": "Consuming a Single Atom Entry\n\n\nSingle Atom \n<entry>\n elements are also valid by themselves. Usually the URL for\nan entry is the feed's URL followed by \n/<entryId>\n, such as\n\nhttp://atom.example.com/feed/1\n, using the example URL we used above. This\npattern may exist for some web services which use Atom as a container syntax.\n\n\nIf you read a single entry, you will have a \nZend\\Feed\\Reader\\Entry\\Atom\n object.\n\n\nReading a Single-Entry Atom Feed\n\n\n$entry = Zend\\Feed\\Reader\\Reader::import('http://atom.example.com/feed/1');\necho 'Entry title: ' . $entry->getTitle();\n\n\n\n\n\nImporting requires an HTTP client\n\n\nTo import a feed, you will need to have an \nHTTP client\n\navailable.\n\n\nIf you are not using zend-http, you will need to inject \nReader\n with the HTTP\nclient. See the \nsection on providing a client to Reader\n.",
            "title": "Consuming Atom Entries"
        },
        {
            "location": "/consuming-atom-entry/#consuming-a-single-atom-entry",
            "text": "Single Atom  <entry>  elements are also valid by themselves. Usually the URL for\nan entry is the feed's URL followed by  /<entryId> , such as http://atom.example.com/feed/1 , using the example URL we used above. This\npattern may exist for some web services which use Atom as a container syntax.  If you read a single entry, you will have a  Zend\\Feed\\Reader\\Entry\\Atom  object.",
            "title": "Consuming a Single Atom Entry"
        },
        {
            "location": "/consuming-atom-entry/#reading-a-single-entry-atom-feed",
            "text": "$entry = Zend\\Feed\\Reader\\Reader::import('http://atom.example.com/feed/1');\necho 'Entry title: ' . $entry->getTitle();",
            "title": "Reading a Single-Entry Atom Feed"
        },
        {
            "location": "/consuming-atom-entry/#importing-requires-an-http-client",
            "text": "To import a feed, you will need to have an  HTTP client \navailable.  If you are not using zend-http, you will need to inject  Reader  with the HTTP\nclient. See the  section on providing a client to Reader .",
            "title": "Importing requires an HTTP client"
        },
        {
            "location": "/security/",
            "text": "Zend\\Feed\\Reader and Security\n\n\nAs with any data coming from a source that is beyond the developer's control,\nspecial attention needs to be given to securing, validating and filtering that\ndata. Similar to data input to our application by users, data coming from RSS\nand Atom feeds should also be considered unsafe and potentially dangerous, as it\nallows the delivery of HTML and \nxHTML\n.\nBecause data validation and filtration is out of \nZend\\Feed\n's scope, this task\nis left for implementation by the developer, by using libraries such as\nzend-escaper for escaping and \nHTMLPurifier\n for\nvalidating and filtering feed data.\n\n\nEscaping and filtering of potentially insecure data is highly recommended before\noutputting it anywhere in our application or before storing that data in some\nstorage engine (be it a simple file or a database.).\n\n\nFiltering data using HTMLPurifier\n\n\nCurrently, the best available library for filtering and validating (x)HTML data\nin PHP is \nHTMLPurifier\n, and, as such, is the\nrecommended tool for this task.  HTMLPurifier works by filtering out all (x)HTML\nfrom the data, except for the tags and attributes specifically allowed in a\nwhitelist, and by checking and fixing nesting of tags, ensuring\nstandards-compliant output.\n\n\nThe following examples will show a basic usage of HTMLPurifier, but developers\nare urged to go through and read \nHTMLPurifier's documentation\n.\n\n\n// Setting HTMLPurifier's options\n$options = [\n    // Allow only paragraph tags\n    // and anchor tags wit the href attribute\n    [\n        'HTML.Allowed',\n        'p,a[href]'\n    ],\n    // Format end output with Tidy\n    [\n        'Output.TidyFormat',\n        true\n    ],\n    // Assume XHTML 1.0 Strict Doctype\n    [\n        'HTML.Doctype',\n        'XHTML 1.0 Strict'\n    ],\n    // Disable cache, but see note after the example\n    [\n        'Cache.DefinitionImpl',\n        null\n    ]\n];\n\n// Configuring HTMLPurifier\n$config = HTMLPurifier_Config::createDefault();\nforeach ($options as $option) {\n    $config->set($option[0], $option[1]);\n}\n\n// Creating a HTMLPurifier with it's config\n$purifier = new HTMLPurifier($config);\n\n// Fetch the RSS\ntry {\n   $rss = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rss/');\n} catch (Zend\\Feed\\Exception\\Reader\\RuntimeException $e) {\n   // feed import failed\n   echo \"Exception caught importing feed: {$e->getMessage()}\\n\";\n   exit;\n}\n\n// Initialize the channel data array\n// See that we're cleaning the description with HTMLPurifier\n$channel = [\n   'title'       => $rss->getTitle(),\n   'link'        => $rss->getLink(),\n   'description' => $purifier->purify($rss->getDescription()),\n   'items'       => [],\n];\n\n// Loop over each channel item and store relevant data\n// See that we're cleaning the descriptions with HTMLPurifier\nforeach ($rss as $item) {\n   $channel['items'][] = [\n       'title'       => $item->getTitle(),\n       'link'        => $item->getLink(),\n       'description' => $purifier->purify($item->getDescription()),\n   ];\n}\n\n\n\n\n\nTidy is required\n\n\nHTMLPurifier is using the PHP \nTidy extension\n to clean\nand repair the final output. If this extension is not available, it will\nsilently fail, but its availability has no impact on the library's security.\n\n\nCaching\n\n\nFor the sake of this example, the HTMLPurifier's cache is disabled, but it is\nrecommended to configure caching and use its standalone include file as it can\nimprove the performance of HTMLPurifier substantially.\n\n\n\n\nEscaping data using zend-escaper\n\n\nTo help prevent XSS attacks, Zend Framework provides the \nzend-escaper component\n,\nwhich complies to the current \nOWASP recommendations\n,\nand as such, is the recommended tool for escaping HTML tags and attributes,\nJavascript, CSS and URLs before outputting any potentially insecure data to the\nusers.\n\n\ntry {\n    $rss = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rss/');\n} catch (Zend\\Feed\\Exception\\Reader\\RuntimeException $e) {\n    // feed import failed\n    echo \"Exception caught importing feed: {$e->getMessage()}\\n\";\n    exit;\n}\n\n// Validate all URIs\n$linkValidator = new Zend\\Validator\\Uri;\n$link = null;\nif ($linkValidator->isValid($rss->getLink())) {\n    $link = $rss->getLink();\n}\n\n// Escaper used for escaping data\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n\n// Initialize the channel data array\n$channel = [\n    'title'       => $escaper->escapeHtml($rss->getTitle()),\n    'link'        => $escaper->escapeUrl($link),\n    'description' => $escaper->escapeHtml($rss->getDescription()),\n    'items'       => [],\n];\n\n// Loop over each channel item and store relevant data\nforeach ($rss as $item) {\n    $link = null;\n    if ($linkValidator->isValid($rss->getLink())) {\n        $link = $item->getLink();\n    }\n    $channel['items'][] = [\n        'title'       => $escaper->escapeHtml($item->getTitle()),\n        'link'        => $escaper->escapeUrl($link),\n        'description' => $escaper->escapeHtml($item->getDescription()),\n    ];\n}\n\n\n\nThe feed data is now safe for output to HTML templates. You can, of course, skip\nescaping when simply storing the data persistently, but remember to escape it on\noutput later!\n\n\nOf course, these are just basic examples, and cannot cover all possible\nscenarios that you, as a developer, can, and most likely will, encounter. Your\nresponsibility is to learn what libraries and tools are at your disposal, and\nwhen and how to use them to secure your web applications.",
            "title": "Security"
        },
        {
            "location": "/security/#zend92feed92reader-and-security",
            "text": "As with any data coming from a source that is beyond the developer's control,\nspecial attention needs to be given to securing, validating and filtering that\ndata. Similar to data input to our application by users, data coming from RSS\nand Atom feeds should also be considered unsafe and potentially dangerous, as it\nallows the delivery of HTML and  xHTML .\nBecause data validation and filtration is out of  Zend\\Feed 's scope, this task\nis left for implementation by the developer, by using libraries such as\nzend-escaper for escaping and  HTMLPurifier  for\nvalidating and filtering feed data.  Escaping and filtering of potentially insecure data is highly recommended before\noutputting it anywhere in our application or before storing that data in some\nstorage engine (be it a simple file or a database.).",
            "title": "Zend\\Feed\\Reader and Security"
        },
        {
            "location": "/security/#filtering-data-using-htmlpurifier",
            "text": "Currently, the best available library for filtering and validating (x)HTML data\nin PHP is  HTMLPurifier , and, as such, is the\nrecommended tool for this task.  HTMLPurifier works by filtering out all (x)HTML\nfrom the data, except for the tags and attributes specifically allowed in a\nwhitelist, and by checking and fixing nesting of tags, ensuring\nstandards-compliant output.  The following examples will show a basic usage of HTMLPurifier, but developers\nare urged to go through and read  HTMLPurifier's documentation .  // Setting HTMLPurifier's options\n$options = [\n    // Allow only paragraph tags\n    // and anchor tags wit the href attribute\n    [\n        'HTML.Allowed',\n        'p,a[href]'\n    ],\n    // Format end output with Tidy\n    [\n        'Output.TidyFormat',\n        true\n    ],\n    // Assume XHTML 1.0 Strict Doctype\n    [\n        'HTML.Doctype',\n        'XHTML 1.0 Strict'\n    ],\n    // Disable cache, but see note after the example\n    [\n        'Cache.DefinitionImpl',\n        null\n    ]\n];\n\n// Configuring HTMLPurifier\n$config = HTMLPurifier_Config::createDefault();\nforeach ($options as $option) {\n    $config->set($option[0], $option[1]);\n}\n\n// Creating a HTMLPurifier with it's config\n$purifier = new HTMLPurifier($config);\n\n// Fetch the RSS\ntry {\n   $rss = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rss/');\n} catch (Zend\\Feed\\Exception\\Reader\\RuntimeException $e) {\n   // feed import failed\n   echo \"Exception caught importing feed: {$e->getMessage()}\\n\";\n   exit;\n}\n\n// Initialize the channel data array\n// See that we're cleaning the description with HTMLPurifier\n$channel = [\n   'title'       => $rss->getTitle(),\n   'link'        => $rss->getLink(),\n   'description' => $purifier->purify($rss->getDescription()),\n   'items'       => [],\n];\n\n// Loop over each channel item and store relevant data\n// See that we're cleaning the descriptions with HTMLPurifier\nforeach ($rss as $item) {\n   $channel['items'][] = [\n       'title'       => $item->getTitle(),\n       'link'        => $item->getLink(),\n       'description' => $purifier->purify($item->getDescription()),\n   ];\n}",
            "title": "Filtering data using HTMLPurifier"
        },
        {
            "location": "/security/#tidy-is-required",
            "text": "HTMLPurifier is using the PHP  Tidy extension  to clean\nand repair the final output. If this extension is not available, it will\nsilently fail, but its availability has no impact on the library's security.",
            "title": "Tidy is required"
        },
        {
            "location": "/security/#caching",
            "text": "For the sake of this example, the HTMLPurifier's cache is disabled, but it is\nrecommended to configure caching and use its standalone include file as it can\nimprove the performance of HTMLPurifier substantially.",
            "title": "Caching"
        },
        {
            "location": "/security/#escaping-data-using-zend-escaper",
            "text": "To help prevent XSS attacks, Zend Framework provides the  zend-escaper component ,\nwhich complies to the current  OWASP recommendations ,\nand as such, is the recommended tool for escaping HTML tags and attributes,\nJavascript, CSS and URLs before outputting any potentially insecure data to the\nusers.  try {\n    $rss = Zend\\Feed\\Reader\\Reader::import('http://www.planet-php.net/rss/');\n} catch (Zend\\Feed\\Exception\\Reader\\RuntimeException $e) {\n    // feed import failed\n    echo \"Exception caught importing feed: {$e->getMessage()}\\n\";\n    exit;\n}\n\n// Validate all URIs\n$linkValidator = new Zend\\Validator\\Uri;\n$link = null;\nif ($linkValidator->isValid($rss->getLink())) {\n    $link = $rss->getLink();\n}\n\n// Escaper used for escaping data\n$escaper = new Zend\\Escaper\\Escaper('utf-8');\n\n// Initialize the channel data array\n$channel = [\n    'title'       => $escaper->escapeHtml($rss->getTitle()),\n    'link'        => $escaper->escapeUrl($link),\n    'description' => $escaper->escapeHtml($rss->getDescription()),\n    'items'       => [],\n];\n\n// Loop over each channel item and store relevant data\nforeach ($rss as $item) {\n    $link = null;\n    if ($linkValidator->isValid($rss->getLink())) {\n        $link = $item->getLink();\n    }\n    $channel['items'][] = [\n        'title'       => $escaper->escapeHtml($item->getTitle()),\n        'link'        => $escaper->escapeUrl($link),\n        'description' => $escaper->escapeHtml($item->getDescription()),\n    ];\n}  The feed data is now safe for output to HTML templates. You can, of course, skip\nescaping when simply storing the data persistently, but remember to escape it on\noutput later!  Of course, these are just basic examples, and cannot cover all possible\nscenarios that you, as a developer, can, and most likely will, encounter. Your\nresponsibility is to learn what libraries and tools are at your disposal, and\nwhen and how to use them to secure your web applications.",
            "title": "Escaping data using zend-escaper"
        },
        {
            "location": "/writer/",
            "text": "Zend\\Feed\\Writer\n\n\nZend\\Feed\\Writer\n is the sibling component to \nZend\\Feed\\Reader\n responsible\nfor \ngenerating\n feeds. It supports the Atom 1.0 specification (RFC 4287) and\nRSS 2.0 as specified by the RSS Advisory Board (RSS 2.0.11). It does not deviate\nfrom these standards. It does, however, offer a simple extension system which\nallows for any extension and module for either of these two specifications to be\nimplemented if they are not provided out of the box.\n\n\nIn many ways, \nZend\\Feed\\Writer\n is the inverse of \nZend\\Feed\\Reader\n. Where\n\nZend\\Reader\\Reader\n focuses on providing an easy to use architecture fronted by\ngetter methods, \nZend\\Feed\\Writer\n is fronted by similarly named setters or\nmutators. This ensures the API won't pose a learning curve to anyone familiar\nwith \nZend\\Feed\\Reader\n.\n\n\nAs a result of this design, the rest may even be obvious. Behind the scenes,\ndata set on any \nZend\\Feed\\Writer\\Writer\n instance is translated at render time\nonto a DOMDocument object using the necessary feed elements. For each supported\nfeed type there is both an Atom 1.0 and RSS 2.0 renderer. Using a DOMDocument\nclass rather than a templating solution has numerous advantages, the most\nobvious being the ability to export the DOMDocument for additional processing\nand relying on PHP DOM for correct and valid rendering.\n\n\nArchitecture\n\n\nThe architecture of \nZend\\Feed\\Writer\n is very simple. It has two core sets of\nclasses: data containers and renderers.\n\n\nThe containers include the \nZend\\Feed\\Writer\\Feed\n and \nZend\\Feed\\Writer\\Entry\n\nclasses. The Entry classes can be attached to any Feed class. The sole purpose\nof these containers is to collect data about the feed to generate using a simple\ninterface of setter methods. These methods perform some data validity testing.\nFor example, it will validate any passed URIs, dates, etc. These checks are not\ntied to any of the feed standards definitions. The container objects also\ncontain methods to allow for fast rendering and export of the final feed, and\nthese can be reused at will.\n\n\nIn addition to the main data container classes, there are two additional Atom\n2.0-specific classes: \nZend\\Feed\\Writer\\Source\n and \nZend\\Feed\\Writer\\Deleted\n.\nThe former implements Atom 2.0 source elements which carry source feed metadata\nfor a specific entry within an aggregate feed (i.e. the current feed is not the\nentry's original source). The latter implements the \nAtom Tombstones RFC\n,\nallowing feeds to carry references to entries which have been deleted.\n\n\nWhile there are two main data container types, there are four renderers: two\nmatching container renderers per supported feed type. Each renderer accepts a\ncontainer, and, based on its content, attempts to generate valid feed markup. If\nthe renderer is unable to generate valid feed markup (perhaps due to the\ncontainer missing an obligatory data point), it will report this by throwing an\nexception. While it is possible to ignore exceptions, this removes the default\nsafeguard of ensuring you have sufficient data set to render a wholly valid\nfeed.\n\n\nTo explain this more clearly: you may construct a set of data containers for a\nfeed where there is a Feed container, into which has been added some Entry\ncontainers and a Deleted container. This forms a data hierarchy resembling a\nnormal feed. When rendering is performed, this hierarchy has its pieces passed\nto relevant renderers, and the partial feeds (all DOMDocuments) are then pieced\ntogether to create a complete feed. In the case of Source or Deleted (Tombstone)\ncontainers, these are rendered only for Atom 2.0 and ignored for RSS.\n\n\nDue to the system being divided between data containers and renderers,\nextensions have more mandatory requirements than their equivalents in the\n\nZend\\Feed\\Reader\n subcomponent.  A typical extension offering namespaced feed\nand entry level elements must itself reflect the exact same architecture: i.e.\nit must offer both feed and entry level data containers, and matching renderers.\nThere is, fortunately, no complex integration work required since all extension\nclasses are simply registered and automatically used by the core classes. We\ncover extensions in more detail at the end of this chapter.\n\n\nGetting Started\n\n\nTo use \nZend\\Feed\\Writer\\Writer\n, you will provide it with data, and then\ntrigger the renderer. What follows is an example demonstrating generation of a\nminimal Atom 1.0 feed. Each feed or entry uses a separate data container.\n\n\nuse Zend\\Feed\\Writer\\Feed;\n\n/**\n * Create the parent feed\n */\n$feed = new Feed;\n$feed->setTitle(\"Paddy's Blog\");\n$feed->setLink('http://www.example.com');\n$feed->setFeedLink('http://www.example.com/atom', 'atom');\n$feed->addAuthor([\n    'name'  => 'Paddy',\n    'email' => 'paddy@example.com',\n    'uri'   => 'http://www.example.com',\n]);\n$feed->setDateModified(time());\n$feed->addHub('http://pubsubhubbub.appspot.com/');\n\n/**\n * Add one or more entries. Note that entries must\n * be manually added once created.\n */\n$entry = $feed->createEntry();\n$entry->setTitle('All Your Base Are Belong To Us');\n$entry->setLink('http://www.example.com/all-your-base-are-belong-to-us');\n$entry->addAuthor([\n    'name'  => 'Paddy',\n    'email' => 'paddy@example.com',\n    'uri'   => 'http://www.example.com',\n]);\n$entry->setDateModified(time());\n$entry->setDateCreated(time());\n$entry->setDescription('Exposing the difficulty of porting games to English.');\n$entry->setContent(\n    'I am not writing the article. The example is long enough as is ;).'\n);\n$feed->addEntry($entry);\n\n/**\n * Render the resulting feed to Atom 1.0 and assign to $out.\n * You can substitute \"atom\" with \"rss\" to generate an RSS 2.0 feed.\n */\n$out = $feed->export('atom');\n\n\n\nThe output rendered should be as follows:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<feed xmlns=\"http://www.w3.org/2005/Atom\">\n    <title type=\"text\">Paddy's Blog</title>\n    <subtitle type=\"text\">Writing about PC Games since 176 BC.</subtitle>\n    <updated>2009-12-14T20:28:18+00:00</updated>\n    <generator uri=\"http://framework.zend.com\" version=\"1.10.0alpha\">\n        Zend\\Feed\\Writer\n    </generator>\n    <link rel=\"alternate\" type=\"text/html\" href=\"http://www.example.com\"/>\n    <link rel=\"self\" type=\"application/atom+xml\"\n        href=\"http://www.example.com/atom\"/>\n    <id>http://www.example.com</id>\n    <author>\n        <name>Paddy</name>\n        <email>paddy@example.com</email>\n        <uri>http://www.example.com</uri>\n    </author>\n    <link rel=\"hub\" href=\"http://pubsubhubbub.appspot.com/\"/>\n    <entry>\n        <title type=\"html\"><![CDATA[All Your Base Are Belong To\n            Us]]></title>\n        <summary type=\"html\">\n            <![CDATA[Exposing the difficultly of porting games to\n                English.]]>\n        </summary>\n        <published>2009-12-14T20:28:18+00:00</published>\n        <updated>2009-12-14T20:28:18+00:00</updated>\n        <link rel=\"alternate\" type=\"text/html\"\n             href=\"http://www.example.com/all-your-base-are-belong-to-us\"/>\n        <id>http://www.example.com/all-your-base-are-belong-to-us</id>\n        <author>\n            <name>Paddy</name>\n            <email>paddy@example.com</email>\n            <uri>http://www.example.com</uri>\n        </author>\n        <content type=\"html\">\n            <![CDATA[I am not writing the article.\n                     The example is long enough as is ;).]]>\n        </content>\n    </entry>\n</feed>\n\n\n\nThis is a perfectly valid Atom 1.0 example. It should be noted that omitting an\nobligatory point of data, such as a title, will trigger an exception when\nrendering as Atom 1.0. This will differ for RSS 2.0, since a title may be\nomitted so long as a description is present. This gives rise to exceptions that\ndiffer between the two standards depending on the renderer in use. By design,\n\nZend\\Feed\\Writer\n will not render an invalid feed for either standard\nunless the end-user deliberately elects to ignore all exceptions. This built in\nsafeguard was added to ensure users without in-depth knowledge of the relevant\nspecifications have a bit less to worry about.\n\n\nSetting Feed Data Points\n\n\nBefore you can render a feed, you must first setup the data necessary for the\nfeed being rendered.  This utilises a simple setter style API, which doubles as\na method for validating the data being set. By design, the API closely matches\nthat for \nZend\\Feed\\Reader\n to avoid undue confusion and uncertainty.\n\n\nZend\\Feed\\Writer\n offers this API via its data container classes\n\nZend\\Feed\\Writer\\Feed\n and \nZend\\Feed\\Writer\\Entry\n (not to mention the Atom\n2.0 specific and extension classes). These classes merely store all feed data in\na type-agnostic manner, meaning you may reuse any data container with any\nrenderer without requiring additional work. Both classes are also amenable to\nextensions, meaning that an extension may define its own container classes which\nare registered to the base container classes as extensions, and are checked when\nany method call triggers the base container's \n__call()\n method, allowing method\noverloading to the extension classes.\n\n\nHere's a summary of the Core API for Feeds. You should note it comprises not\nonly the basic RSS and Atom standards, but also accounts for a number of\nincluded extensions bundled with \nZend\\Feed\\Writer\n. The naming of these\nextension sourced methods remain fairly generic; all extension methods operate\nat the same level as the Core API, though we do allow you to retrieve any\nspecific extension object separately if required.\n\n\nThe Feed API for data is contained in \nZend\\Feed\\Writer\\Feed\n. In addition to the API\ndetailed below, the class also implements the \nCountable\n and \nIterator\n interfaces.\n\n\nFeed API Methods\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetId()\n\n\nSet a unique identifier associated with this feed. For Atom 1.0 this is an \natom:id\n element, whereas for RSS 2.0 it is added as a \nguid\n element.  These are optional so long as a link is added; i.e. if no identifier is provided, the link is used.\n\n\n\n\n\n\nsetTitle()\n\n\nSet the title of the feed.\n\n\n\n\n\n\nsetDescription()\n\n\nSet the text description of the feed.\n\n\n\n\n\n\nsetLink()\n\n\nSet a URI to the HTML website containing the same or similar information as this feed (i.e. if the feed is from a blog, it should provide the blog's URI where the HTML version of the entries can be read).\n\n\n\n\n\n\nsetFeedLink()\n\n\nSet a URI to an XML feed, whether it is to the feed being generated, or an alternate URI pointing to the same feed but in a different format. At a minimum, it is recommended to include a link to the feed being generated so it has an identifiable final URI allowing a client to track its location changes without necessitating constant redirects. The parameters are the feed URI and type (one of \"atom\", \"rss\", or \"rdf\").\n\n\n\n\n\n\naddAuthors()\n\n\nSets the data for authors. The parameter is an array of array,s where each sub-array may contain the keys \"name\", \"email\", and \"uri\". The \"uri\" value is only applicable for Atom feeds, since RSS contains no facility to show it. For RSS 2.0, rendering will create two elements: an author element containing the email reference with the name in brackets, and a Dublin Core creator element only containing the name.\n\n\n\n\n\n\naddAuthor()\n\n\nSets the data for a single author following the same array format as described above for a single sub-array.\n\n\n\n\n\n\nsetDateCreated()\n\n\nSets the date on which this feed was created. Generally only applicable to Atom, where it represents the date the resource described by an Atom 1.0 document was created. The expected parameter may be a UNIX timestamp or a \nDateTime\n object.\n\n\n\n\n\n\nsetDateModified()\n\n\nSets the date on which this feed was last modified. The expected parameter may be a UNIX timestamp or a \nDateTime\n object.\n\n\n\n\n\n\nsetLastBuildDate()\n\n\nSets the date on which this feed was last build. The expected parameter may be a UNIX timestamp or a \nDateTime\n object. This will only be rendered for RSS 2.0 feeds, and is automatically rendered as the current date by default when not explicitly set.\n\n\n\n\n\n\nsetLanguage()\n\n\nSets the language of the feed. This will be omitted unless set.\n\n\n\n\n\n\nsetGenerator()\n\n\nAllows the setting of a generator. The parameter should be an array containing the keys \"name\", \"version\", and \"uri\". If omitted a default generator will be added referencing \nZend\\Feed\\Writer\n, the current zend-version version, and the Framework's URI.\n\n\n\n\n\n\nsetCopyright()\n\n\nSets a copyright notice associated with the feed.\n\n\n\n\n\n\naddHubs()\n\n\nAccepts an array of Pubsubhubbub Hub Endpoints to be rendered in the feed as Atom links so that PuSH Subscribers may subscribe to your feed. Note that you must implement a Pubsubhubbub Publisher in order for real-time updates to be enabled. A Publisher may be implemented using \nZend\\Feed\\Pubsubhubbub\\Publisher\n. The method \naddHub()\n allows adding a single hub at a time.\n\n\n\n\n\n\naddCategories()\n\n\nAccepts an array of categories for rendering, where each element is itself an array whose possible keys include \"term\", \"label\", and \"scheme\". The \"term\" is a typically a category name suitable for inclusion in a URI. The \"label\" may be a human readable category name supporting special characters (it is HTML encoded during rendering) and is a required key. The \"scheme\" (called the domain in RSS) is optional, but must be a valid URI. The method \naddCategory()\n allows adding a single category at a time.\n\n\n\n\n\n\nsetImage()\n\n\nAccepts an array of image metadata for an RSS image or Atom logo.  Atom 1.0 only requires a URI. RSS 2.0 requires a URI, HTML link, and an image title. RSS 2.0 optionally may send a width, height, and image description. To provide these, use an array argument with the following keys: \"uri\", \"link\", \"title\", \"description\", \"height\", and \"width\". The RSS 2.0 HTML link should point to the feed source's HTML page.\n\n\n\n\n\n\ncreateEntry()\n\n\nReturns a new instance of \nZend\\Feed\\Writer\\Entry\n. This is the Entry data container. New entries are not automatically assigned to the current feed, so you must explicitly call \naddEntry()\n to add the entry for rendering.\n\n\n\n\n\n\naddEntry()\n\n\nAdds an instance of \nZend\\Feed\\Writer\\Entry\n to the current feed container for rendering.\n\n\n\n\n\n\ncreateTombstone()\n\n\nReturns a new instance of \nZend\\Feed\\Writer\\Deleted\n. This is the Atom 2.0 Tombstone data container. New entries are not automatically assigned to the current feed, so you must explicitly call \naddTombstone()\n to add the deleted entry for rendering.\n\n\n\n\n\n\naddTombstone()\n\n\nAdds an instance of \nZend\\Feed\\Writer\\Deleted\n to the current feed container for rendering.\n\n\n\n\n\n\nremoveEntry()\n\n\nAccepts a parameter indicating an array index of the entry to remove from the feed.\n\n\n\n\n\n\nexport()\n\n\nExports the entire data hierarchy to an XML feed. The method has two parameters. The first is the feed type, one of \"atom\" or \"rss\". The second is an optional boolean to set indicating whether or not Exceptions are thrown. The default is \nTRUE\n.\n\n\n\n\n\n\n\n\n\n\nRetrieval methods\n\n\nIn addition to the setters listed above, \nFeed\n instances also provide\nmatching getters to retrieve data from the \nFeed\n data container. For\nexample, \nsetImage()\n is matched with a \ngetImage()\n method.\n\n\n\n\nSetting Entry Data Points\n\n\nBelow is a summary of the Core API for entries and items. You should note that\nit covers not only the basic RSS and Atom standards, but also a number of\nincluded extensions bundled with \nZend\\Feed\\Writer\n. The naming of these\nextension sourced methods remain fairly generic; all extension methods operate\nat the same level as the Core API, though we do allow you to retrieve any\nspecific extension object separately if required.\n\n\nThe Entry \nAPI\n for data is contained in \nZend\\Feed\\Writer\\Entry\n.\n\n\nEntry API Methods\n\n\n\n\n\n\n\n\nMethod\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsetId()\n\n\nSet a unique identifier associated with this entry. For Atom 1.0 this is an \natom:id\n element, whereas for RSS 2.0 it is added as a \nguid\n element.  These are optional so long as a link is added; i.e. if no identifier is provided, the link is used.\n\n\n\n\n\n\nsetTitle()\n\n\nSet the title of the entry.\n\n\n\n\n\n\nsetDescription()\n\n\nSet the text description of the entry.\n\n\n\n\n\n\nsetContent()\n\n\nSet the content of the entry.\n\n\n\n\n\n\nsetLink()\n\n\nSet a URI to the HTML website containing the same or similar information as this entry (i.e. if the feed is from a blog, it should provide the blog article's URI where the HTML version of the entry can be read).\n\n\n\n\n\n\naddAuthors()\n\n\nSets the data for authors. The parameter is an array of array,s where each sub-array may contain the keys \"name\", \"email\", and \"uri\". The \"uri\" value is only applicable for Atom feeds, since RSS contains no facility to show it. For RSS 2.0, rendering will create two elements: an author element containing the email reference with the name in brackets, and a Dublin Core creator element only containing the name.\n\n\n\n\n\n\naddAuthor()\n\n\nSets the data for a single author following the same format as described above for a single sub-array.\n\n\n\n\n\n\nsetDateCreated()\n\n\nSets the date on which this entry was created. Generally only applicable to Atom where it represents the date the resource described by an Atom 1.0 document was created. The expected parameter may be a UNIX timestamp or a \nDateTime\n object. If omitted, the date used will be the current date and time.\n\n\n\n\n\n\nsetDateModified()\n\n\nSets the date on which this entry was last modified. The expected parameter may be a UNIX timestamp or a \nDateTime\n object. If omitted, the date used will be the current date and time.\n\n\n\n\n\n\nsetCopyright()\n\n\nSets a copyright notice associated with the entry.\n\n\n\n\n\n\naddCategories()\n\n\nAccepts an array of categories for rendering, where each element is itself an array whose possible keys include \"term\", \"label\", and \"scheme\". The \"term\" is a typically a category name suitable for inclusion in a URI. The \"label\" may be a human readable category name supporting special characters (it is encoded during rendering) and is a required key. The \"scheme\" (called the domain in RSS) is optional but must be a valid URI.\n\n\n\n\n\n\naddCategory()\n\n\nSets the data for a single category following the same format as described above for a single sub-array.\n\n\n\n\n\n\nsetCommentCount()\n\n\nSets the number of comments associated with this entry. Rendering differs between RSS and Atom 2.0 depending on the element or attribute needed.\n\n\n\n\n\n\nsetCommentLink()\n\n\nSets a link to an HTML page containing comments associated with this entry.\n\n\n\n\n\n\nsetCommentFeedLink()\n\n\nSets a link to an XML feed containing comments associated with this entry. The parameter is an array containing the keys \"uri\" and \"type\", where the type is one of \"rdf\", \"rss\", or \"atom\".\n\n\n\n\n\n\nsetCommentFeedLinks()\n\n\nSame as \nsetCommentFeedLink()\n, except it accepts an array of arrays, where each subarray contains the expected parameters of \nsetCommentFeedLink()\n.\n\n\n\n\n\n\nsetEncoding()\n\n\nSets the encoding of entry text. This will default to UTF-8, which is the preferred encoding.\n\n\n\n\n\n\n\n\n\n\nRetrieval methods\n\n\nIn addition to the setters listed above, \nEntry\n instances also provide\nmatching getters to retrieve data from the \nEntry\n data container. For\nexample, \nsetContent()\n is matched with a \ngetContent()\n method.\n\n\n\n\nExtensions\n\n\n\n\nTODO",
            "title": "Writer"
        },
        {
            "location": "/writer/#zend92feed92writer",
            "text": "Zend\\Feed\\Writer  is the sibling component to  Zend\\Feed\\Reader  responsible\nfor  generating  feeds. It supports the Atom 1.0 specification (RFC 4287) and\nRSS 2.0 as specified by the RSS Advisory Board (RSS 2.0.11). It does not deviate\nfrom these standards. It does, however, offer a simple extension system which\nallows for any extension and module for either of these two specifications to be\nimplemented if they are not provided out of the box.  In many ways,  Zend\\Feed\\Writer  is the inverse of  Zend\\Feed\\Reader . Where Zend\\Reader\\Reader  focuses on providing an easy to use architecture fronted by\ngetter methods,  Zend\\Feed\\Writer  is fronted by similarly named setters or\nmutators. This ensures the API won't pose a learning curve to anyone familiar\nwith  Zend\\Feed\\Reader .  As a result of this design, the rest may even be obvious. Behind the scenes,\ndata set on any  Zend\\Feed\\Writer\\Writer  instance is translated at render time\nonto a DOMDocument object using the necessary feed elements. For each supported\nfeed type there is both an Atom 1.0 and RSS 2.0 renderer. Using a DOMDocument\nclass rather than a templating solution has numerous advantages, the most\nobvious being the ability to export the DOMDocument for additional processing\nand relying on PHP DOM for correct and valid rendering.",
            "title": "Zend\\Feed\\Writer"
        },
        {
            "location": "/writer/#architecture",
            "text": "The architecture of  Zend\\Feed\\Writer  is very simple. It has two core sets of\nclasses: data containers and renderers.  The containers include the  Zend\\Feed\\Writer\\Feed  and  Zend\\Feed\\Writer\\Entry \nclasses. The Entry classes can be attached to any Feed class. The sole purpose\nof these containers is to collect data about the feed to generate using a simple\ninterface of setter methods. These methods perform some data validity testing.\nFor example, it will validate any passed URIs, dates, etc. These checks are not\ntied to any of the feed standards definitions. The container objects also\ncontain methods to allow for fast rendering and export of the final feed, and\nthese can be reused at will.  In addition to the main data container classes, there are two additional Atom\n2.0-specific classes:  Zend\\Feed\\Writer\\Source  and  Zend\\Feed\\Writer\\Deleted .\nThe former implements Atom 2.0 source elements which carry source feed metadata\nfor a specific entry within an aggregate feed (i.e. the current feed is not the\nentry's original source). The latter implements the  Atom Tombstones RFC ,\nallowing feeds to carry references to entries which have been deleted.  While there are two main data container types, there are four renderers: two\nmatching container renderers per supported feed type. Each renderer accepts a\ncontainer, and, based on its content, attempts to generate valid feed markup. If\nthe renderer is unable to generate valid feed markup (perhaps due to the\ncontainer missing an obligatory data point), it will report this by throwing an\nexception. While it is possible to ignore exceptions, this removes the default\nsafeguard of ensuring you have sufficient data set to render a wholly valid\nfeed.  To explain this more clearly: you may construct a set of data containers for a\nfeed where there is a Feed container, into which has been added some Entry\ncontainers and a Deleted container. This forms a data hierarchy resembling a\nnormal feed. When rendering is performed, this hierarchy has its pieces passed\nto relevant renderers, and the partial feeds (all DOMDocuments) are then pieced\ntogether to create a complete feed. In the case of Source or Deleted (Tombstone)\ncontainers, these are rendered only for Atom 2.0 and ignored for RSS.  Due to the system being divided between data containers and renderers,\nextensions have more mandatory requirements than their equivalents in the Zend\\Feed\\Reader  subcomponent.  A typical extension offering namespaced feed\nand entry level elements must itself reflect the exact same architecture: i.e.\nit must offer both feed and entry level data containers, and matching renderers.\nThere is, fortunately, no complex integration work required since all extension\nclasses are simply registered and automatically used by the core classes. We\ncover extensions in more detail at the end of this chapter.",
            "title": "Architecture"
        },
        {
            "location": "/writer/#getting-started",
            "text": "To use  Zend\\Feed\\Writer\\Writer , you will provide it with data, and then\ntrigger the renderer. What follows is an example demonstrating generation of a\nminimal Atom 1.0 feed. Each feed or entry uses a separate data container.  use Zend\\Feed\\Writer\\Feed;\n\n/**\n * Create the parent feed\n */\n$feed = new Feed;\n$feed->setTitle(\"Paddy's Blog\");\n$feed->setLink('http://www.example.com');\n$feed->setFeedLink('http://www.example.com/atom', 'atom');\n$feed->addAuthor([\n    'name'  => 'Paddy',\n    'email' => 'paddy@example.com',\n    'uri'   => 'http://www.example.com',\n]);\n$feed->setDateModified(time());\n$feed->addHub('http://pubsubhubbub.appspot.com/');\n\n/**\n * Add one or more entries. Note that entries must\n * be manually added once created.\n */\n$entry = $feed->createEntry();\n$entry->setTitle('All Your Base Are Belong To Us');\n$entry->setLink('http://www.example.com/all-your-base-are-belong-to-us');\n$entry->addAuthor([\n    'name'  => 'Paddy',\n    'email' => 'paddy@example.com',\n    'uri'   => 'http://www.example.com',\n]);\n$entry->setDateModified(time());\n$entry->setDateCreated(time());\n$entry->setDescription('Exposing the difficulty of porting games to English.');\n$entry->setContent(\n    'I am not writing the article. The example is long enough as is ;).'\n);\n$feed->addEntry($entry);\n\n/**\n * Render the resulting feed to Atom 1.0 and assign to $out.\n * You can substitute \"atom\" with \"rss\" to generate an RSS 2.0 feed.\n */\n$out = $feed->export('atom');  The output rendered should be as follows:  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<feed xmlns=\"http://www.w3.org/2005/Atom\">\n    <title type=\"text\">Paddy's Blog</title>\n    <subtitle type=\"text\">Writing about PC Games since 176 BC.</subtitle>\n    <updated>2009-12-14T20:28:18+00:00</updated>\n    <generator uri=\"http://framework.zend.com\" version=\"1.10.0alpha\">\n        Zend\\Feed\\Writer\n    </generator>\n    <link rel=\"alternate\" type=\"text/html\" href=\"http://www.example.com\"/>\n    <link rel=\"self\" type=\"application/atom+xml\"\n        href=\"http://www.example.com/atom\"/>\n    <id>http://www.example.com</id>\n    <author>\n        <name>Paddy</name>\n        <email>paddy@example.com</email>\n        <uri>http://www.example.com</uri>\n    </author>\n    <link rel=\"hub\" href=\"http://pubsubhubbub.appspot.com/\"/>\n    <entry>\n        <title type=\"html\"><![CDATA[All Your Base Are Belong To\n            Us]]></title>\n        <summary type=\"html\">\n            <![CDATA[Exposing the difficultly of porting games to\n                English.]]>\n        </summary>\n        <published>2009-12-14T20:28:18+00:00</published>\n        <updated>2009-12-14T20:28:18+00:00</updated>\n        <link rel=\"alternate\" type=\"text/html\"\n             href=\"http://www.example.com/all-your-base-are-belong-to-us\"/>\n        <id>http://www.example.com/all-your-base-are-belong-to-us</id>\n        <author>\n            <name>Paddy</name>\n            <email>paddy@example.com</email>\n            <uri>http://www.example.com</uri>\n        </author>\n        <content type=\"html\">\n            <![CDATA[I am not writing the article.\n                     The example is long enough as is ;).]]>\n        </content>\n    </entry>\n</feed>  This is a perfectly valid Atom 1.0 example. It should be noted that omitting an\nobligatory point of data, such as a title, will trigger an exception when\nrendering as Atom 1.0. This will differ for RSS 2.0, since a title may be\nomitted so long as a description is present. This gives rise to exceptions that\ndiffer between the two standards depending on the renderer in use. By design, Zend\\Feed\\Writer  will not render an invalid feed for either standard\nunless the end-user deliberately elects to ignore all exceptions. This built in\nsafeguard was added to ensure users without in-depth knowledge of the relevant\nspecifications have a bit less to worry about.",
            "title": "Getting Started"
        },
        {
            "location": "/writer/#setting-feed-data-points",
            "text": "Before you can render a feed, you must first setup the data necessary for the\nfeed being rendered.  This utilises a simple setter style API, which doubles as\na method for validating the data being set. By design, the API closely matches\nthat for  Zend\\Feed\\Reader  to avoid undue confusion and uncertainty.  Zend\\Feed\\Writer  offers this API via its data container classes Zend\\Feed\\Writer\\Feed  and  Zend\\Feed\\Writer\\Entry  (not to mention the Atom\n2.0 specific and extension classes). These classes merely store all feed data in\na type-agnostic manner, meaning you may reuse any data container with any\nrenderer without requiring additional work. Both classes are also amenable to\nextensions, meaning that an extension may define its own container classes which\nare registered to the base container classes as extensions, and are checked when\nany method call triggers the base container's  __call()  method, allowing method\noverloading to the extension classes.  Here's a summary of the Core API for Feeds. You should note it comprises not\nonly the basic RSS and Atom standards, but also accounts for a number of\nincluded extensions bundled with  Zend\\Feed\\Writer . The naming of these\nextension sourced methods remain fairly generic; all extension methods operate\nat the same level as the Core API, though we do allow you to retrieve any\nspecific extension object separately if required.  The Feed API for data is contained in  Zend\\Feed\\Writer\\Feed . In addition to the API\ndetailed below, the class also implements the  Countable  and  Iterator  interfaces.",
            "title": "Setting Feed Data Points"
        },
        {
            "location": "/writer/#feed-api-methods",
            "text": "Method  Description      setId()  Set a unique identifier associated with this feed. For Atom 1.0 this is an  atom:id  element, whereas for RSS 2.0 it is added as a  guid  element.  These are optional so long as a link is added; i.e. if no identifier is provided, the link is used.    setTitle()  Set the title of the feed.    setDescription()  Set the text description of the feed.    setLink()  Set a URI to the HTML website containing the same or similar information as this feed (i.e. if the feed is from a blog, it should provide the blog's URI where the HTML version of the entries can be read).    setFeedLink()  Set a URI to an XML feed, whether it is to the feed being generated, or an alternate URI pointing to the same feed but in a different format. At a minimum, it is recommended to include a link to the feed being generated so it has an identifiable final URI allowing a client to track its location changes without necessitating constant redirects. The parameters are the feed URI and type (one of \"atom\", \"rss\", or \"rdf\").    addAuthors()  Sets the data for authors. The parameter is an array of array,s where each sub-array may contain the keys \"name\", \"email\", and \"uri\". The \"uri\" value is only applicable for Atom feeds, since RSS contains no facility to show it. For RSS 2.0, rendering will create two elements: an author element containing the email reference with the name in brackets, and a Dublin Core creator element only containing the name.    addAuthor()  Sets the data for a single author following the same array format as described above for a single sub-array.    setDateCreated()  Sets the date on which this feed was created. Generally only applicable to Atom, where it represents the date the resource described by an Atom 1.0 document was created. The expected parameter may be a UNIX timestamp or a  DateTime  object.    setDateModified()  Sets the date on which this feed was last modified. The expected parameter may be a UNIX timestamp or a  DateTime  object.    setLastBuildDate()  Sets the date on which this feed was last build. The expected parameter may be a UNIX timestamp or a  DateTime  object. This will only be rendered for RSS 2.0 feeds, and is automatically rendered as the current date by default when not explicitly set.    setLanguage()  Sets the language of the feed. This will be omitted unless set.    setGenerator()  Allows the setting of a generator. The parameter should be an array containing the keys \"name\", \"version\", and \"uri\". If omitted a default generator will be added referencing  Zend\\Feed\\Writer , the current zend-version version, and the Framework's URI.    setCopyright()  Sets a copyright notice associated with the feed.    addHubs()  Accepts an array of Pubsubhubbub Hub Endpoints to be rendered in the feed as Atom links so that PuSH Subscribers may subscribe to your feed. Note that you must implement a Pubsubhubbub Publisher in order for real-time updates to be enabled. A Publisher may be implemented using  Zend\\Feed\\Pubsubhubbub\\Publisher . The method  addHub()  allows adding a single hub at a time.    addCategories()  Accepts an array of categories for rendering, where each element is itself an array whose possible keys include \"term\", \"label\", and \"scheme\". The \"term\" is a typically a category name suitable for inclusion in a URI. The \"label\" may be a human readable category name supporting special characters (it is HTML encoded during rendering) and is a required key. The \"scheme\" (called the domain in RSS) is optional, but must be a valid URI. The method  addCategory()  allows adding a single category at a time.    setImage()  Accepts an array of image metadata for an RSS image or Atom logo.  Atom 1.0 only requires a URI. RSS 2.0 requires a URI, HTML link, and an image title. RSS 2.0 optionally may send a width, height, and image description. To provide these, use an array argument with the following keys: \"uri\", \"link\", \"title\", \"description\", \"height\", and \"width\". The RSS 2.0 HTML link should point to the feed source's HTML page.    createEntry()  Returns a new instance of  Zend\\Feed\\Writer\\Entry . This is the Entry data container. New entries are not automatically assigned to the current feed, so you must explicitly call  addEntry()  to add the entry for rendering.    addEntry()  Adds an instance of  Zend\\Feed\\Writer\\Entry  to the current feed container for rendering.    createTombstone()  Returns a new instance of  Zend\\Feed\\Writer\\Deleted . This is the Atom 2.0 Tombstone data container. New entries are not automatically assigned to the current feed, so you must explicitly call  addTombstone()  to add the deleted entry for rendering.    addTombstone()  Adds an instance of  Zend\\Feed\\Writer\\Deleted  to the current feed container for rendering.    removeEntry()  Accepts a parameter indicating an array index of the entry to remove from the feed.    export()  Exports the entire data hierarchy to an XML feed. The method has two parameters. The first is the feed type, one of \"atom\" or \"rss\". The second is an optional boolean to set indicating whether or not Exceptions are thrown. The default is  TRUE .",
            "title": "Feed API Methods"
        },
        {
            "location": "/writer/#retrieval-methods",
            "text": "In addition to the setters listed above,  Feed  instances also provide\nmatching getters to retrieve data from the  Feed  data container. For\nexample,  setImage()  is matched with a  getImage()  method.",
            "title": "Retrieval methods"
        },
        {
            "location": "/writer/#setting-entry-data-points",
            "text": "Below is a summary of the Core API for entries and items. You should note that\nit covers not only the basic RSS and Atom standards, but also a number of\nincluded extensions bundled with  Zend\\Feed\\Writer . The naming of these\nextension sourced methods remain fairly generic; all extension methods operate\nat the same level as the Core API, though we do allow you to retrieve any\nspecific extension object separately if required.  The Entry  API  for data is contained in  Zend\\Feed\\Writer\\Entry .",
            "title": "Setting Entry Data Points"
        },
        {
            "location": "/writer/#entry-api-methods",
            "text": "Method  Description      setId()  Set a unique identifier associated with this entry. For Atom 1.0 this is an  atom:id  element, whereas for RSS 2.0 it is added as a  guid  element.  These are optional so long as a link is added; i.e. if no identifier is provided, the link is used.    setTitle()  Set the title of the entry.    setDescription()  Set the text description of the entry.    setContent()  Set the content of the entry.    setLink()  Set a URI to the HTML website containing the same or similar information as this entry (i.e. if the feed is from a blog, it should provide the blog article's URI where the HTML version of the entry can be read).    addAuthors()  Sets the data for authors. The parameter is an array of array,s where each sub-array may contain the keys \"name\", \"email\", and \"uri\". The \"uri\" value is only applicable for Atom feeds, since RSS contains no facility to show it. For RSS 2.0, rendering will create two elements: an author element containing the email reference with the name in brackets, and a Dublin Core creator element only containing the name.    addAuthor()  Sets the data for a single author following the same format as described above for a single sub-array.    setDateCreated()  Sets the date on which this entry was created. Generally only applicable to Atom where it represents the date the resource described by an Atom 1.0 document was created. The expected parameter may be a UNIX timestamp or a  DateTime  object. If omitted, the date used will be the current date and time.    setDateModified()  Sets the date on which this entry was last modified. The expected parameter may be a UNIX timestamp or a  DateTime  object. If omitted, the date used will be the current date and time.    setCopyright()  Sets a copyright notice associated with the entry.    addCategories()  Accepts an array of categories for rendering, where each element is itself an array whose possible keys include \"term\", \"label\", and \"scheme\". The \"term\" is a typically a category name suitable for inclusion in a URI. The \"label\" may be a human readable category name supporting special characters (it is encoded during rendering) and is a required key. The \"scheme\" (called the domain in RSS) is optional but must be a valid URI.    addCategory()  Sets the data for a single category following the same format as described above for a single sub-array.    setCommentCount()  Sets the number of comments associated with this entry. Rendering differs between RSS and Atom 2.0 depending on the element or attribute needed.    setCommentLink()  Sets a link to an HTML page containing comments associated with this entry.    setCommentFeedLink()  Sets a link to an XML feed containing comments associated with this entry. The parameter is an array containing the keys \"uri\" and \"type\", where the type is one of \"rdf\", \"rss\", or \"atom\".    setCommentFeedLinks()  Same as  setCommentFeedLink() , except it accepts an array of arrays, where each subarray contains the expected parameters of  setCommentFeedLink() .    setEncoding()  Sets the encoding of entry text. This will default to UTF-8, which is the preferred encoding.",
            "title": "Entry API Methods"
        },
        {
            "location": "/writer/#retrieval-methods_1",
            "text": "In addition to the setters listed above,  Entry  instances also provide\nmatching getters to retrieve data from the  Entry  data container. For\nexample,  setContent()  is matched with a  getContent()  method.",
            "title": "Retrieval methods"
        },
        {
            "location": "/writer/#extensions",
            "text": "TODO",
            "title": "Extensions"
        },
        {
            "location": "/pubsubhubbub/",
            "text": "Zend\\Feed\\PubSubHubbub\n\n\nZend\\Feed\\PubSubHubbub\n is an implementation of the \nPubSubHubbub Core 0.2/0.3\nSpecification (Working Draft)\n.\nIt offers implementations of a Pubsubhubbub Publisher and Subscriber suited to\nPHP applications.\n\n\nWhat is PubSubHubbub?\n\n\nPubsubhubbub is an open, simple, web-scale, pubsub protocol. A common use case\nto enable blogs (Publishers) to \"push\" updates from their RSS or Atom feeds\n(Topics) to end Subscribers. These Subscribers will have subscribed to the\nblog's RSS or Atom feed via a Hub, a central server which is notified of any\nupdates by the Publisher, and which then distributes these updates to all\nSubscribers. Any feed may advertise that it supports one or more Hubs using an\nAtom namespaced link element with a rel attribute of \"hub\" (i.e., \nrel=\"hub\"\n).\n\n\nPubsubhubbub has garnered attention because it is a pubsub protocol which is\neasy to implement and which operates over HTTP. Its philosophy is to replace the\ntraditional model where blog feeds have been polled at regular intervals to\ndetect and retrieve updates. Depending on the frequency of polling, this can\ntake a lot of time to propagate updates to interested parties from planet\naggregators to desktop readers. With a pubsub system in place, updates are not\nsimply polled by Subscribers, they are pushed to Subscribers, eliminating any\ndelay. For this reason, Pubsubhubbub forms part of what has been dubbed the\nreal-time web.\n\n\nThe protocol does not exist in isolation. Pubsub systems have been around for a\nwhile, such as the familiar Jabber Publish-Subscribe protocol,\n\nXEP-0060\n, or the less well-known\n\nrssCloud\n (described in 2001).\nHowever, these have not achieved widespread adoption due to either their\ncomplexity, poor timing, or lack of suitability for web applications. rssCloud,\nwhich was recently revived as a response to the appearance of Pubsubhubbub, has\nalso seen its usage increase significantly, though it lacks a formal\nspecification and currently does not support Atom 1.0 feeds.\n\n\nPerhaps surprisingly given its relative early age, Pubsubhubbub is already in\nuse including in Google Reader and Feedburner, and there are plugins available\nfor Wordpress blogs.\n\n\nArchitecture\n\n\nZend\\Feed\\PubSubHubbub\n implements two sides of the Pubsubhubbub 0.2/0.3\nSpecification: a Publisher and a Subscriber. It does not currently implement a\nHub Server.\n\n\nA Publisher is responsible for notifying all supported Hubs (many can be\nsupported to add redundancy to the system) of any updates to its feeds, whether\nthey be Atom or RSS based. This is achieved by pinging the supported Hub Servers\nwith the URL of the updated feed. In Pubsubhubbub terminology, any updatable\nresource capable of being subscribed to is referred to as a Topic. Once a ping\nis received, the Hub will request the updated feed, process it for updated\nitems, and forward all updates to all Subscribers subscribed to that feed.\n\n\nA Subscriber is any party or application which subscribes to one or more Hubs to\nreceive updates from a Topic hosted by a Publisher. The Subscriber never\ndirectly communicates with the Publisher since the Hub acts as an intermediary,\naccepting subscriptions and sending updates to Subscribers. The Subscriber\ntherefore communicates only with the Hub, either to subscribe or unsubscribe to\nTopics, or when it receives updates from the Hub. This communication design\n(\"Fat Pings\") effectively removes the possibility of a \"Thundering Herd\" issue.\n(Thundering Herds occur in a pubsub system where the Hub merely informs\nSubscribers that an update is available, prompting all Subscribers to\nimmediately retrieve the feed from the Publisher, giving rise to a traffic\nspike.) In Pubsubhubbub, the Hub distributes the actual update in a \"Fat Ping\"\nso the Publisher is not subjected to any traffic spike.\n\n\nZend\\Feed\\PubSubHubbub\n implements Pubsubhubbub Publishers and Subscribers with\nthe classes \nZend\\Feed\\PubSubHubbub\\Publisher\n and\n\nZend\\Feed\\PubSubHubbub\\Subscriber\n. In addition, the Subscriber implementation\nmay handle any feed updates forwarded from a Hub by using\n\nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n. These classes, their use cases,\nand etheir APIs are covered in subsequent sections.\n\n\nZend\\Feed\\PubSubHubbub\\Publisher\n\n\nIn Pubsubhubbub, the Publisher is the party publishing a live feed with content\nupdates. This may be a blog, an aggregator, or even a web service with a public\nfeed based API. In order for these updates to be pushed to Subscribers, the\nPublisher must notify all of its supported Hubs that an update has occurred\nusing a simple HTTP POST request containing the URI of the updated Topic (i.e.,\nthe updated RSS or Atom feed). The Hub will confirm receipt of the notification,\nfetch the updated feed, and forward any updates to any Subscribers who have\nsubscribed to that Hub for updates from the relevant feed.\n\n\nBy design, this means the Publisher has very little to do except send these Hub\npings whenever its feeds change. As a result, the Publisher implementation is\nextremely simple to use and requires very little work to setup and use when\nfeeds are updated.\n\n\nZend\\Feed\\PubSubHubbub\\Publisher\n implements a full Pubsubhubbub Publisher. Its\nsetup for use primarily requires that it is configured with the URI endpoint for\nall Hubs to be notified of updates, and the URIs of all Topics to be included in\nthe notifications.\n\n\nThe following example shows a Publisher notifying a collection of Hubs about\nupdates to a pair of local RSS and Atom feeds. The class retains a collection of\nerrors which include the Hub URLs, so that notification can be attempted again\nlater and/or logged if any notifications happen to fail.  Each resulting error\narray also includes a \"response\" key containing the related HTTP response\nobject. In the event of any errors, it is strongly recommended to attempt the\noperation for failed Hub Endpoints at least once more at a future time. This may\nrequire the use of either a scheduled task for this purpose or a job queue,\nthough such extra steps are optional.\n\n\nuse Zend\\Feed\\PubSubHubbub\\Publisher;\n\n$publisher = Publisher;\n$publisher->addHubUrls([\n    'http://pubsubhubbub.appspot.com/',\n    'http://hubbub.example.com',\n]);\n$publisher->addUpdatedTopicUrls([\n    'http://www.example.net/rss',\n    'http://www.example.net/atom',\n]);\n$publisher->notifyAll();\n\nif (! $publisher->isSuccess()) {\n    // check for errors\n    $errors     = $publisher->getErrors();\n    $failedHubs = [];\n    foreach ($errors as $error) {\n        $failedHubs[] = $error['hubUrl'];\n    }\n}\n\n// reschedule notifications for the failed Hubs in $failedHubs\n\n\n\nIf you prefer having more concrete control over the Publisher, the methods\n\naddHubUrls()\n and \naddUpdatedTopicUrls()\n pass each array value to the singular\n\naddHubUrl()\n and \naddUpdatedTopicUrl()\n public methods. There are also matching\n\nremoveUpdatedTopicUrl()\n and \nremoveHubUrl()\n methods.\n\n\nYou can also skip setting Hub URIs, and notify each in turn using the\n\nnotifyHub()\n method which accepts the URI of a Hub endpoint as its only\nargument.\n\n\nThere are no other tasks to cover. The Publisher implementation is very simple\nsince most of the feed processing and distribution is handled by the selected\nHubs. It is, however, important to detect errors and reschedule notifications as\nsoon as possible (with a reasonable maximum number of retries) to ensure\nnotifications reach all Subscribers. In many cases, as a final alternative, Hubs\nmay frequently poll your feeds to offer some additional tolerance for failures\nboth in terms of their own temporary downtime or Publisher errors or downtime.\n\n\nZend\\Feed\\PubSubHubbub\\Subscriber\n\n\nIn Pubsubhubbub, the Subscriber is the party who wishes to receive updates to\nany Topic (RSS or Atom feed). They achieve this by subscribing to one or more of\nthe Hubs advertised by that Topic, usually as a set of one or more Atom 1.0\nlinks with a rel attribute of \"hub\" (i.e., \nrel=\"hub\"\n). The Hub from that point\nforward will send an Atom or RSS feed containing all updates to that\nSubscriber's callback URL when it receives an update notification from the\nPublisher. In this way, the Subscriber need never actually visit the original\nfeed (though it's still recommended at some level to ensure updates are\nretrieved if ever a Hub goes offline). All subscription requests must contain\nthe URI of the Topic being subscribed and a callback URL which the Hub will use\nto confirm the subscription and to forward updates.\n\n\nThe Subscriber therefore has two roles. The first is to \ncreate\n and \nmanage\n\nsubscriptions, including subscribing for new Topics with a Hub, unsubscribing\n(if necessary), and periodically renewing subscriptions, since they may have an\nexpiry set by the Hub. This is handled by \nZend\\Feed\\PubSubHubbub\\Subscriber\n.\n\n\nThe second role is to \naccept updates\n sent by a Hub to the Subscriber's\ncallback URL, i.e. the URI the Subscriber has assigned to handle updates. The\ncallback URL also handles events where the Hub contacts the Subscriber to\nconfirm all subscriptions and unsubscriptions. This is handled by using an\ninstance of \nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n when the callback URL\nis accessed.\n\n\n\n\nQuery strings in callback URLs\n\n\nZend\\Feed\\PubSubHubbub\\Subscriber\n implements the Pubsubhubbub 0.2/0.3\nspecification. As this is a new specification version, not all Hubs currently\nimplement it. The new specification allows the callback URL to include a query\nstring which is used by this class, but not supported by all Hubs. In the\ninterests of maximising compatibility, it is therefore recommended that the\nquery string component of the Subscriber callback URI be presented as a path\nelement, i.e. recognised as a parameter in the route associated with the\ncallback URI and used by the application's router.\n\n\n\n\nSubscribing and Unsubscribing\n\n\nZend\\Feed\\PubSubHubbub\\Subscriber\n implements a full Pubsubhubbub Subscriber\ncapable of subscribing to, or unsubscribing from, any Topic via any Hub\nadvertised by that Topic. It operates in conjunction with\n\nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n, which accepts requests from a Hub\nto confirm all subscription or unsubscription attempts (to prevent third-party\nmisuse).\n\n\nAny subscription (or unsubscription) requires the relevant information before\nproceeding, i.e. the URI of the Topic (Atom or RSS feed) to be subscribed to for\nupdates, and the URI of the endpoint for the Hub which will handle the\nsubscription and forwarding of the updates. The lifetime of a subscription may\nbe determined by the Hub, but most Hubs should support automatic subscription\nrefreshes by checking with the Subscriber. This is supported by\n\nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n and requires no other work on your\npart. It is still strongly recommended that you use the Hub-sourced subscription\ntime-to.live (ttl) to schedule the creation of new subscriptions (the process is\nidentical to that for any new subscription) to refresh it with the Hub. While it\nshould not be necessary per se, it covers cases where a Hub may not support\nautomatic subscription refreshing, and rules out Hub errors for additional\nredundancy.\n\n\nWith the relevant information to hand, a subscription can be attempted as\ndemonstrated below:\n\n\nuse Zend\\Feed\\PubSubHubbub\\Model\\Subscription;\nuse Zend\\Feed\\PubSubHubbub\\Subscriber;\n\n$storage    = new Subscription;\n$subscriber = new Subscriber;\n$subscriber->setStorage($storage);\n$subscriber->addHubUrl('http://hubbub.example.com');\n$subscriber->setTopicUrl('http://www.example.net/rss.xml');\n$subscriber->setCallbackUrl('http://www.mydomain.com/hubbub/callback');\n$subscriber->subscribeAll();\n\n\n\nIn order to store subscriptions and offer access to this data for general use,\nthe component requires a database (a schema is provided later in this section).\nBy default, it is assumed the table name is \"subscription\", and it utilises\n\nZend\\Db\\TableGateway\\TableGateway\n in the background, meaning it will use the\ndefault adapter you have set for your application. You may also pass a specific\ncustom \nZend\\Db\\TableGateway\\TableGateway\n instance into the associated model\n\nZend\\Feed\\PubSubHubbub\\Model\\Subscription\n. This custom adapter may be as\nsimple in intent as changing the table name to use or as complex as you deem\nnecessary.\n\n\nWhile this model is offered as a default ready-to-roll solution, you may create\nyour own model using any other backend or database layer (e.g. Doctrine) so long\nas the resulting class implements the interface\n\nZend\\Feed\\PubSubHubbub\\Model\\SubscriptionInterface\n.\n\n\nAn example schema (MySQL) for a subscription table accessible by the provided\nmodel may look similar to:\n\n\nCREATE TABLE IF NOT EXISTS `subscription` (\n  `id` varchar(32) COLLATE utf8_unicode_ci NOT NULL DEFAULT '',\n  `topic_url` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `hub_url` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `created_time` datetime DEFAULT NULL,\n  `lease_seconds` bigint(20) DEFAULT NULL,\n  `verify_token` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `secret` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `expiration_time` datetime DEFAULT NULL,\n  `subscription_state` varchar(12) COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;\n\n\n\nBehind the scenes, the Subscriber above will send a request to the Hub endpoint\ncontaining the following parameters (based on the previous example):\n\n\n\n\n\n\n\n\nParameter\n\n\nValue\n\n\nExplanation\n\n\n\n\n\n\n\n\n\n\nhub.callback\n\n\nhttp://www.mydomain.com/hubbub/callback?xhub.subscription=5536df06b5dcb966edab3a4c4d56213c16a8184\n\n\nThe URI used by a Hub to contact the Subscriber and either request confirmation of a (un)subscription request, or send updates from subscribed feeds. The appended query string contains a custom parameter (hence the xhub designation). It is a query string parameter preserved by the Hub and re-sent with all Subscriber requests. Its purpose is to allow the Subscriber to identify and look up the subscription associated with any Hub request in a backend storage medium. This is a non-standard parameter used by this component in preference to encoding a subscription key in the URI path, which is difficult to enforce generically. Nevertheless, since not all Hubs support query string parameters, we still strongly recommend adding the subscription key as a path component in the form \nhttp://www.mydomain.com/hubbub/callback/5536df06b5dcb966edab3a4c4d56213c16a8184\n.  This requires defining a route capable of parsing out the final value of the key, retrieving the value, and passing it to the Subscriber callback object. The value should be passed into the method \nZend\\PubSubHubbub\\Subscriber\\Callback::setSubscriptionKey()\n. A detailed example is offered later.\n\n\n\n\n\n\nhub.lease_seconds\n\n\n2592000\n\n\nThe number of seconds for which the Subscriber would like a new subscription to remain valid (i.e. a TTL). Hubs may enforce their own maximum subscription period. All subscriptions should be renewed by re-subscribing before the subscription period ends to ensure continuity of updates. Hubs should additionally attempt to automatically refresh subscriptions before they expire by contacting Subscribers (handled automatically by the \nCallback\n class).\n\n\n\n\n\n\nhub.mode\n\n\nsubscribe\n\n\nValue indicating this is a subscription request. Unsubscription requests would use the \"unsubscribe\" value.\n\n\n\n\n\n\nhub.topic\n\n\nhttp://www.example.net/rss.xml\n\n\nThe URI of the Topic (i.e. Atom or RSS feed) which the Subscriber wishes to subscribe to for updates.\n\n\n\n\n\n\nhub.verify\n\n\nsync\n or \nasync\n\n\nIndicates to the Hub the preferred mode of verifying subscriptions or unsubscriptions. It is repeated twice in order of preference. Technically this component does not distinguish between the two modes and treats both equally.\n\n\n\n\n\n\nhub.verify_token\n\n\n3065919804abcaa7212ae89.879827871253878386\n\n\nA verification token returned to the Subscriber by the Hub when it is confirming a subscription or unsubscription. Offers a measure of reliance that the confirmation request originates from the correct Hub to prevent misuse.\n\n\n\n\n\n\n\n\nYou can modify several of these parameters to indicate a different preference.\nFor example, you can set a different lease seconds value using\n\nZend\\Feed\\PubSubHubbub\\Subscriber::setLeaseSeconds(),\n or show a preference for\nthe \nasync\n verify mode by using \nsetPreferredVerificationMode(Zend\\Feed\\PubSubHubbub\\PubSubHubbub::VERIFICATION_MODE_ASYNC)\n.\nHowever, the Hubs retain the capability to enforce their own preferences, and\nfor this reason the component is deliberately designed to work across almost any\nset of options with minimum end-user configuration required. Conventions are\ngreat when they work!\n\n\n\n\nVerification modes\n\n\nWhile Hubs may require the use of a specific verification mode (both are\nsupported by \nZend\\Feed\\PubSubHubbub\n), you may indicate a specific preference\nusing the \nsetPreferredVerificationMode()\n method. In \nsync\n (synchronous)\nmode, the Hub attempts to confirm a subscription as soon as it is received,\nand before responding to the subscription request. In \nasync\n (asynchronous)\nmode, the Hub will return a response to the subscription request immediately,\nand its verification request may occur at a later time. Since\n\nZend\\Feed\\PubSubHubbub\n implements the Subscriber verification role as a\nseparate callback class and requires the use of a backend storage medium, it\nactually supports both transparently. In terms of end-user performance,\nasynchronous verification is very much preferred to eliminate the impact of a\npoorly performing Hub tying up end-user server resources and connections for\ntoo long.\n\n\n\n\nUnsubscribing from a Topic follows the exact same pattern as the previous\nexample, with the exception that we should call \nunsubscribeAll()\n instead. The\nparameters included are identical to a subscription request with the exception\nthat \nhub.mode\n is set to \"unsubscribe\".\n\n\nBy default, a new instance of \nZend\\PubSubHubbub\\Subscriber\n will attempt to use\na database backed storage medium which defaults to using the default zend-db\nadapter with a table name of \"subscription\". It is recommended to set a custom\nstorage solution where these defaults are not apt either by passing in a new\nmodel supporting the required interface or by passing a new instance of\n\nZend\\Db\\TableGateway\\TableGateway\n to the default model's constructor to change\nthe used table name.\n\n\nHandling Subscriber Callbacks\n\n\nWhenever a subscription or unsubscription request is made, the Hub must verify\nthe request by forwarding a new verification request to the callback URL set in\nthe subscription or unsubscription parameters. To handle these Hub requests,\nwhich will include all future communications containing Topic (feed) updates,\nthe callback URL should trigger the execution of an instance of\n\nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n to handle the request.\n\n\nThe \nCallback\n class should be configured to use the same storage medium as the\n\nSubscriber\n class. The bulk of the work is handled internal to these classes.\n\n\nuse Zend\\Feed\\PubSubHubbub\\Model\\Subscription;\nuse Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback;\n\n$storage = new Subscription();\n$callback = new Callback();\n$callback->setStorage($storage);\n$callback->handle();\n$callback->sendResponse();\n\n/*\n * Check if the callback resulting in the receipt of a feed update.\n * Otherwise it was either a (un)sub verification request or invalid request.\n * Typically we need do nothing other than add feed update handling; the rest\n * is handled internally by the class.\n */\nif ($callback->hasFeedUpdate()) {\n    $feedString = $callback->getFeedUpdate();\n    /*\n     * Process the feed update asynchronously to avoid a Hub timeout.\n     */\n}\n\n\n\n\n\nQuery and body parameters\n\n\nIt should be noted that \nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n may\nindependently parse any incoming query string and other parameters. This is\nnecessary since PHP alters the structure and keys of a query string when it is\nparsed into the \n$_GET\n or \n$_POST\n superglobals; for example, all duplicate\nkeys are ignored and periods are converted to underscores. Pubsubhubbub\nfeatures both of these in the query strings it generates.\n\n\nAlways delay feed processing\n\n\nIt is essential that developers recognise that Hubs are only concerned with\nsending requests and receiving a response which verifies its receipt. If a\nfeed update is received, it should never be processed on the spot since this\nleaves the Hub waiting for a response. Rather, any processing should be\noffloaded to another process or deferred until after a response has been\nreturned to the Hub. One symptom of a failure to promptly complete Hub\nrequests is that a Hub may continue to attempt delivery of the update or\nverification request leading to duplicated update attempts being processed by\nthe Subscriber. This appears problematic, but in reality a Hub may apply a\ntimeout of just a few seconds, and if no response is received within that time\nit may disconnect (assuming a delivery failure) and retry later. Note that\nHubs are expected to distribute vast volumes of updates so their resources are\nstretched; please process feeds asynchronously (e.g. in a separate process or\na job queue or even a cronjob) as much as possible.\n\n\n\n\nSetting Up And Using A Callback URL Route\n\n\nAs noted earlier, the \nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n class\nreceives the combined key associated with any subscription from the Hub via one\nof two methods. The technically preferred method is to add this key to the\ncallback URL employed by the Hub in all future requests using a query string\nparameter with the key \nxhub.subscription\n. However, for historical reasons\n(primarily that this was not supported in Pubsubhubbub 0.1, and a late addition\nto 0.2 ), it is strongly recommended to use the most compatible means of adding\nthis key to the callback URL by appending it to the URL's path.\n\n\nThus the URL \nhttp://www.example.com/callback?xhub.subscription=key\n would become\n\nhttp://www.example.com/callback/key\n.\n\n\nSince the query string method is the default in anticipation of a greater level\nof future support for the full 0.2/0.3 specification, this requires some\nadditional work to implement.\n\n\nThe first step is to make the \nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback\n class\naware of the path contained subscription key. It's manually injected; therefore\nit also requires manually defining a route for this purpose. This is achieved by\ncalled the method \nZend\\Feed\\PubSubHubbub\\Subscriber\\Callback::setSubscriptionKey()\n\nwith the parameter being the key value available from the router. The example\nbelow demonstrates this using a zend-mvc controller.\n\n\nuse Zend\\Feed\\PubSubHubbub\\Model\\Subscription;\nuse Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass CallbackController extends AbstractActionController\n{\n\n    public function indexAction()\n    {\n        $storage = new Subscription();\n        $callback = new Callback();\n        $callback->setStorage($storage);\n\n        /*\n         * Inject subscription key parsing from URL path using\n         * a parameter from the router.\n         */\n        $subscriptionKey = $this->params()->fromRoute('subkey');\n        $callback->setSubscriptionKey($subscriptionKey);\n        $callback->handle();\n        $callback->sendResponse();\n\n        /*\n         * Check if the callback resulting in the receipt of a feed update.\n         * Otherwise it was either a (un)sub verification request or invalid\n         * request. Typically we need do nothing other than add feed update\n         * handling; the rest is handled internally by the class.\n         */\n        if ($callback->hasFeedUpdate()) {\n            $feedString = $callback->getFeedUpdate();\n            /*\n             *  Process the feed update asynchronously to avoid a Hub timeout.\n             */\n        }\n    }\n}\n\n\n\nThe example below illustrates adding a route mapping the path segment to a route\nparameter, using zend-mvc:\n\n\nuse Zend\\Mvc\\Router\\Http\\Segment as SegmentRoute;;\n\n// Route defininition for enabling appending of a PuSH Subscription's lookup key\n$route = SegmentRoute::factory([\n   'route' => '/callback/:subkey',\n   'constraints' => [\n      'subkey' => '[a-z0-9]+',\n   ],\n   'defaults' => [\n      'controller' => 'application-index',\n      'action' => 'index',\n   ]\n]);",
            "title": "Pubsubhubbub"
        },
        {
            "location": "/pubsubhubbub/#zend92feed92pubsubhubbub",
            "text": "Zend\\Feed\\PubSubHubbub  is an implementation of the  PubSubHubbub Core 0.2/0.3\nSpecification (Working Draft) .\nIt offers implementations of a Pubsubhubbub Publisher and Subscriber suited to\nPHP applications.",
            "title": "Zend\\Feed\\PubSubHubbub"
        },
        {
            "location": "/pubsubhubbub/#what-is-pubsubhubbub",
            "text": "Pubsubhubbub is an open, simple, web-scale, pubsub protocol. A common use case\nto enable blogs (Publishers) to \"push\" updates from their RSS or Atom feeds\n(Topics) to end Subscribers. These Subscribers will have subscribed to the\nblog's RSS or Atom feed via a Hub, a central server which is notified of any\nupdates by the Publisher, and which then distributes these updates to all\nSubscribers. Any feed may advertise that it supports one or more Hubs using an\nAtom namespaced link element with a rel attribute of \"hub\" (i.e.,  rel=\"hub\" ).  Pubsubhubbub has garnered attention because it is a pubsub protocol which is\neasy to implement and which operates over HTTP. Its philosophy is to replace the\ntraditional model where blog feeds have been polled at regular intervals to\ndetect and retrieve updates. Depending on the frequency of polling, this can\ntake a lot of time to propagate updates to interested parties from planet\naggregators to desktop readers. With a pubsub system in place, updates are not\nsimply polled by Subscribers, they are pushed to Subscribers, eliminating any\ndelay. For this reason, Pubsubhubbub forms part of what has been dubbed the\nreal-time web.  The protocol does not exist in isolation. Pubsub systems have been around for a\nwhile, such as the familiar Jabber Publish-Subscribe protocol, XEP-0060 , or the less well-known rssCloud  (described in 2001).\nHowever, these have not achieved widespread adoption due to either their\ncomplexity, poor timing, or lack of suitability for web applications. rssCloud,\nwhich was recently revived as a response to the appearance of Pubsubhubbub, has\nalso seen its usage increase significantly, though it lacks a formal\nspecification and currently does not support Atom 1.0 feeds.  Perhaps surprisingly given its relative early age, Pubsubhubbub is already in\nuse including in Google Reader and Feedburner, and there are plugins available\nfor Wordpress blogs.",
            "title": "What is PubSubHubbub?"
        },
        {
            "location": "/pubsubhubbub/#architecture",
            "text": "Zend\\Feed\\PubSubHubbub  implements two sides of the Pubsubhubbub 0.2/0.3\nSpecification: a Publisher and a Subscriber. It does not currently implement a\nHub Server.  A Publisher is responsible for notifying all supported Hubs (many can be\nsupported to add redundancy to the system) of any updates to its feeds, whether\nthey be Atom or RSS based. This is achieved by pinging the supported Hub Servers\nwith the URL of the updated feed. In Pubsubhubbub terminology, any updatable\nresource capable of being subscribed to is referred to as a Topic. Once a ping\nis received, the Hub will request the updated feed, process it for updated\nitems, and forward all updates to all Subscribers subscribed to that feed.  A Subscriber is any party or application which subscribes to one or more Hubs to\nreceive updates from a Topic hosted by a Publisher. The Subscriber never\ndirectly communicates with the Publisher since the Hub acts as an intermediary,\naccepting subscriptions and sending updates to Subscribers. The Subscriber\ntherefore communicates only with the Hub, either to subscribe or unsubscribe to\nTopics, or when it receives updates from the Hub. This communication design\n(\"Fat Pings\") effectively removes the possibility of a \"Thundering Herd\" issue.\n(Thundering Herds occur in a pubsub system where the Hub merely informs\nSubscribers that an update is available, prompting all Subscribers to\nimmediately retrieve the feed from the Publisher, giving rise to a traffic\nspike.) In Pubsubhubbub, the Hub distributes the actual update in a \"Fat Ping\"\nso the Publisher is not subjected to any traffic spike.  Zend\\Feed\\PubSubHubbub  implements Pubsubhubbub Publishers and Subscribers with\nthe classes  Zend\\Feed\\PubSubHubbub\\Publisher  and Zend\\Feed\\PubSubHubbub\\Subscriber . In addition, the Subscriber implementation\nmay handle any feed updates forwarded from a Hub by using Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback . These classes, their use cases,\nand etheir APIs are covered in subsequent sections.",
            "title": "Architecture"
        },
        {
            "location": "/pubsubhubbub/#zend92feed92pubsubhubbub92publisher",
            "text": "In Pubsubhubbub, the Publisher is the party publishing a live feed with content\nupdates. This may be a blog, an aggregator, or even a web service with a public\nfeed based API. In order for these updates to be pushed to Subscribers, the\nPublisher must notify all of its supported Hubs that an update has occurred\nusing a simple HTTP POST request containing the URI of the updated Topic (i.e.,\nthe updated RSS or Atom feed). The Hub will confirm receipt of the notification,\nfetch the updated feed, and forward any updates to any Subscribers who have\nsubscribed to that Hub for updates from the relevant feed.  By design, this means the Publisher has very little to do except send these Hub\npings whenever its feeds change. As a result, the Publisher implementation is\nextremely simple to use and requires very little work to setup and use when\nfeeds are updated.  Zend\\Feed\\PubSubHubbub\\Publisher  implements a full Pubsubhubbub Publisher. Its\nsetup for use primarily requires that it is configured with the URI endpoint for\nall Hubs to be notified of updates, and the URIs of all Topics to be included in\nthe notifications.  The following example shows a Publisher notifying a collection of Hubs about\nupdates to a pair of local RSS and Atom feeds. The class retains a collection of\nerrors which include the Hub URLs, so that notification can be attempted again\nlater and/or logged if any notifications happen to fail.  Each resulting error\narray also includes a \"response\" key containing the related HTTP response\nobject. In the event of any errors, it is strongly recommended to attempt the\noperation for failed Hub Endpoints at least once more at a future time. This may\nrequire the use of either a scheduled task for this purpose or a job queue,\nthough such extra steps are optional.  use Zend\\Feed\\PubSubHubbub\\Publisher;\n\n$publisher = Publisher;\n$publisher->addHubUrls([\n    'http://pubsubhubbub.appspot.com/',\n    'http://hubbub.example.com',\n]);\n$publisher->addUpdatedTopicUrls([\n    'http://www.example.net/rss',\n    'http://www.example.net/atom',\n]);\n$publisher->notifyAll();\n\nif (! $publisher->isSuccess()) {\n    // check for errors\n    $errors     = $publisher->getErrors();\n    $failedHubs = [];\n    foreach ($errors as $error) {\n        $failedHubs[] = $error['hubUrl'];\n    }\n}\n\n// reschedule notifications for the failed Hubs in $failedHubs  If you prefer having more concrete control over the Publisher, the methods addHubUrls()  and  addUpdatedTopicUrls()  pass each array value to the singular addHubUrl()  and  addUpdatedTopicUrl()  public methods. There are also matching removeUpdatedTopicUrl()  and  removeHubUrl()  methods.  You can also skip setting Hub URIs, and notify each in turn using the notifyHub()  method which accepts the URI of a Hub endpoint as its only\nargument.  There are no other tasks to cover. The Publisher implementation is very simple\nsince most of the feed processing and distribution is handled by the selected\nHubs. It is, however, important to detect errors and reschedule notifications as\nsoon as possible (with a reasonable maximum number of retries) to ensure\nnotifications reach all Subscribers. In many cases, as a final alternative, Hubs\nmay frequently poll your feeds to offer some additional tolerance for failures\nboth in terms of their own temporary downtime or Publisher errors or downtime.",
            "title": "Zend\\Feed\\PubSubHubbub\\Publisher"
        },
        {
            "location": "/pubsubhubbub/#zend92feed92pubsubhubbub92subscriber",
            "text": "In Pubsubhubbub, the Subscriber is the party who wishes to receive updates to\nany Topic (RSS or Atom feed). They achieve this by subscribing to one or more of\nthe Hubs advertised by that Topic, usually as a set of one or more Atom 1.0\nlinks with a rel attribute of \"hub\" (i.e.,  rel=\"hub\" ). The Hub from that point\nforward will send an Atom or RSS feed containing all updates to that\nSubscriber's callback URL when it receives an update notification from the\nPublisher. In this way, the Subscriber need never actually visit the original\nfeed (though it's still recommended at some level to ensure updates are\nretrieved if ever a Hub goes offline). All subscription requests must contain\nthe URI of the Topic being subscribed and a callback URL which the Hub will use\nto confirm the subscription and to forward updates.  The Subscriber therefore has two roles. The first is to  create  and  manage \nsubscriptions, including subscribing for new Topics with a Hub, unsubscribing\n(if necessary), and periodically renewing subscriptions, since they may have an\nexpiry set by the Hub. This is handled by  Zend\\Feed\\PubSubHubbub\\Subscriber .  The second role is to  accept updates  sent by a Hub to the Subscriber's\ncallback URL, i.e. the URI the Subscriber has assigned to handle updates. The\ncallback URL also handles events where the Hub contacts the Subscriber to\nconfirm all subscriptions and unsubscriptions. This is handled by using an\ninstance of  Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback  when the callback URL\nis accessed.",
            "title": "Zend\\Feed\\PubSubHubbub\\Subscriber"
        },
        {
            "location": "/pubsubhubbub/#query-strings-in-callback-urls",
            "text": "Zend\\Feed\\PubSubHubbub\\Subscriber  implements the Pubsubhubbub 0.2/0.3\nspecification. As this is a new specification version, not all Hubs currently\nimplement it. The new specification allows the callback URL to include a query\nstring which is used by this class, but not supported by all Hubs. In the\ninterests of maximising compatibility, it is therefore recommended that the\nquery string component of the Subscriber callback URI be presented as a path\nelement, i.e. recognised as a parameter in the route associated with the\ncallback URI and used by the application's router.",
            "title": "Query strings in callback URLs"
        },
        {
            "location": "/pubsubhubbub/#subscribing-and-unsubscribing",
            "text": "Zend\\Feed\\PubSubHubbub\\Subscriber  implements a full Pubsubhubbub Subscriber\ncapable of subscribing to, or unsubscribing from, any Topic via any Hub\nadvertised by that Topic. It operates in conjunction with Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback , which accepts requests from a Hub\nto confirm all subscription or unsubscription attempts (to prevent third-party\nmisuse).  Any subscription (or unsubscription) requires the relevant information before\nproceeding, i.e. the URI of the Topic (Atom or RSS feed) to be subscribed to for\nupdates, and the URI of the endpoint for the Hub which will handle the\nsubscription and forwarding of the updates. The lifetime of a subscription may\nbe determined by the Hub, but most Hubs should support automatic subscription\nrefreshes by checking with the Subscriber. This is supported by Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback  and requires no other work on your\npart. It is still strongly recommended that you use the Hub-sourced subscription\ntime-to.live (ttl) to schedule the creation of new subscriptions (the process is\nidentical to that for any new subscription) to refresh it with the Hub. While it\nshould not be necessary per se, it covers cases where a Hub may not support\nautomatic subscription refreshing, and rules out Hub errors for additional\nredundancy.  With the relevant information to hand, a subscription can be attempted as\ndemonstrated below:  use Zend\\Feed\\PubSubHubbub\\Model\\Subscription;\nuse Zend\\Feed\\PubSubHubbub\\Subscriber;\n\n$storage    = new Subscription;\n$subscriber = new Subscriber;\n$subscriber->setStorage($storage);\n$subscriber->addHubUrl('http://hubbub.example.com');\n$subscriber->setTopicUrl('http://www.example.net/rss.xml');\n$subscriber->setCallbackUrl('http://www.mydomain.com/hubbub/callback');\n$subscriber->subscribeAll();  In order to store subscriptions and offer access to this data for general use,\nthe component requires a database (a schema is provided later in this section).\nBy default, it is assumed the table name is \"subscription\", and it utilises Zend\\Db\\TableGateway\\TableGateway  in the background, meaning it will use the\ndefault adapter you have set for your application. You may also pass a specific\ncustom  Zend\\Db\\TableGateway\\TableGateway  instance into the associated model Zend\\Feed\\PubSubHubbub\\Model\\Subscription . This custom adapter may be as\nsimple in intent as changing the table name to use or as complex as you deem\nnecessary.  While this model is offered as a default ready-to-roll solution, you may create\nyour own model using any other backend or database layer (e.g. Doctrine) so long\nas the resulting class implements the interface Zend\\Feed\\PubSubHubbub\\Model\\SubscriptionInterface .  An example schema (MySQL) for a subscription table accessible by the provided\nmodel may look similar to:  CREATE TABLE IF NOT EXISTS `subscription` (\n  `id` varchar(32) COLLATE utf8_unicode_ci NOT NULL DEFAULT '',\n  `topic_url` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `hub_url` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `created_time` datetime DEFAULT NULL,\n  `lease_seconds` bigint(20) DEFAULT NULL,\n  `verify_token` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `secret` varchar(255) COLLATE utf8_unicode_ci DEFAULT NULL,\n  `expiration_time` datetime DEFAULT NULL,\n  `subscription_state` varchar(12) COLLATE utf8_unicode_ci DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_unicode_ci;  Behind the scenes, the Subscriber above will send a request to the Hub endpoint\ncontaining the following parameters (based on the previous example):     Parameter  Value  Explanation      hub.callback  http://www.mydomain.com/hubbub/callback?xhub.subscription=5536df06b5dcb966edab3a4c4d56213c16a8184  The URI used by a Hub to contact the Subscriber and either request confirmation of a (un)subscription request, or send updates from subscribed feeds. The appended query string contains a custom parameter (hence the xhub designation). It is a query string parameter preserved by the Hub and re-sent with all Subscriber requests. Its purpose is to allow the Subscriber to identify and look up the subscription associated with any Hub request in a backend storage medium. This is a non-standard parameter used by this component in preference to encoding a subscription key in the URI path, which is difficult to enforce generically. Nevertheless, since not all Hubs support query string parameters, we still strongly recommend adding the subscription key as a path component in the form  http://www.mydomain.com/hubbub/callback/5536df06b5dcb966edab3a4c4d56213c16a8184 .  This requires defining a route capable of parsing out the final value of the key, retrieving the value, and passing it to the Subscriber callback object. The value should be passed into the method  Zend\\PubSubHubbub\\Subscriber\\Callback::setSubscriptionKey() . A detailed example is offered later.    hub.lease_seconds  2592000  The number of seconds for which the Subscriber would like a new subscription to remain valid (i.e. a TTL). Hubs may enforce their own maximum subscription period. All subscriptions should be renewed by re-subscribing before the subscription period ends to ensure continuity of updates. Hubs should additionally attempt to automatically refresh subscriptions before they expire by contacting Subscribers (handled automatically by the  Callback  class).    hub.mode  subscribe  Value indicating this is a subscription request. Unsubscription requests would use the \"unsubscribe\" value.    hub.topic  http://www.example.net/rss.xml  The URI of the Topic (i.e. Atom or RSS feed) which the Subscriber wishes to subscribe to for updates.    hub.verify  sync  or  async  Indicates to the Hub the preferred mode of verifying subscriptions or unsubscriptions. It is repeated twice in order of preference. Technically this component does not distinguish between the two modes and treats both equally.    hub.verify_token  3065919804abcaa7212ae89.879827871253878386  A verification token returned to the Subscriber by the Hub when it is confirming a subscription or unsubscription. Offers a measure of reliance that the confirmation request originates from the correct Hub to prevent misuse.     You can modify several of these parameters to indicate a different preference.\nFor example, you can set a different lease seconds value using Zend\\Feed\\PubSubHubbub\\Subscriber::setLeaseSeconds(),  or show a preference for\nthe  async  verify mode by using  setPreferredVerificationMode(Zend\\Feed\\PubSubHubbub\\PubSubHubbub::VERIFICATION_MODE_ASYNC) .\nHowever, the Hubs retain the capability to enforce their own preferences, and\nfor this reason the component is deliberately designed to work across almost any\nset of options with minimum end-user configuration required. Conventions are\ngreat when they work!",
            "title": "Subscribing and Unsubscribing"
        },
        {
            "location": "/pubsubhubbub/#verification-modes",
            "text": "While Hubs may require the use of a specific verification mode (both are\nsupported by  Zend\\Feed\\PubSubHubbub ), you may indicate a specific preference\nusing the  setPreferredVerificationMode()  method. In  sync  (synchronous)\nmode, the Hub attempts to confirm a subscription as soon as it is received,\nand before responding to the subscription request. In  async  (asynchronous)\nmode, the Hub will return a response to the subscription request immediately,\nand its verification request may occur at a later time. Since Zend\\Feed\\PubSubHubbub  implements the Subscriber verification role as a\nseparate callback class and requires the use of a backend storage medium, it\nactually supports both transparently. In terms of end-user performance,\nasynchronous verification is very much preferred to eliminate the impact of a\npoorly performing Hub tying up end-user server resources and connections for\ntoo long.   Unsubscribing from a Topic follows the exact same pattern as the previous\nexample, with the exception that we should call  unsubscribeAll()  instead. The\nparameters included are identical to a subscription request with the exception\nthat  hub.mode  is set to \"unsubscribe\".  By default, a new instance of  Zend\\PubSubHubbub\\Subscriber  will attempt to use\na database backed storage medium which defaults to using the default zend-db\nadapter with a table name of \"subscription\". It is recommended to set a custom\nstorage solution where these defaults are not apt either by passing in a new\nmodel supporting the required interface or by passing a new instance of Zend\\Db\\TableGateway\\TableGateway  to the default model's constructor to change\nthe used table name.",
            "title": "Verification modes"
        },
        {
            "location": "/pubsubhubbub/#handling-subscriber-callbacks",
            "text": "Whenever a subscription or unsubscription request is made, the Hub must verify\nthe request by forwarding a new verification request to the callback URL set in\nthe subscription or unsubscription parameters. To handle these Hub requests,\nwhich will include all future communications containing Topic (feed) updates,\nthe callback URL should trigger the execution of an instance of Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback  to handle the request.  The  Callback  class should be configured to use the same storage medium as the Subscriber  class. The bulk of the work is handled internal to these classes.  use Zend\\Feed\\PubSubHubbub\\Model\\Subscription;\nuse Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback;\n\n$storage = new Subscription();\n$callback = new Callback();\n$callback->setStorage($storage);\n$callback->handle();\n$callback->sendResponse();\n\n/*\n * Check if the callback resulting in the receipt of a feed update.\n * Otherwise it was either a (un)sub verification request or invalid request.\n * Typically we need do nothing other than add feed update handling; the rest\n * is handled internally by the class.\n */\nif ($callback->hasFeedUpdate()) {\n    $feedString = $callback->getFeedUpdate();\n    /*\n     * Process the feed update asynchronously to avoid a Hub timeout.\n     */\n}",
            "title": "Handling Subscriber Callbacks"
        },
        {
            "location": "/pubsubhubbub/#query-and-body-parameters",
            "text": "It should be noted that  Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback  may\nindependently parse any incoming query string and other parameters. This is\nnecessary since PHP alters the structure and keys of a query string when it is\nparsed into the  $_GET  or  $_POST  superglobals; for example, all duplicate\nkeys are ignored and periods are converted to underscores. Pubsubhubbub\nfeatures both of these in the query strings it generates.",
            "title": "Query and body parameters"
        },
        {
            "location": "/pubsubhubbub/#always-delay-feed-processing",
            "text": "It is essential that developers recognise that Hubs are only concerned with\nsending requests and receiving a response which verifies its receipt. If a\nfeed update is received, it should never be processed on the spot since this\nleaves the Hub waiting for a response. Rather, any processing should be\noffloaded to another process or deferred until after a response has been\nreturned to the Hub. One symptom of a failure to promptly complete Hub\nrequests is that a Hub may continue to attempt delivery of the update or\nverification request leading to duplicated update attempts being processed by\nthe Subscriber. This appears problematic, but in reality a Hub may apply a\ntimeout of just a few seconds, and if no response is received within that time\nit may disconnect (assuming a delivery failure) and retry later. Note that\nHubs are expected to distribute vast volumes of updates so their resources are\nstretched; please process feeds asynchronously (e.g. in a separate process or\na job queue or even a cronjob) as much as possible.",
            "title": "Always delay feed processing"
        },
        {
            "location": "/pubsubhubbub/#setting-up-and-using-a-callback-url-route",
            "text": "As noted earlier, the  Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback  class\nreceives the combined key associated with any subscription from the Hub via one\nof two methods. The technically preferred method is to add this key to the\ncallback URL employed by the Hub in all future requests using a query string\nparameter with the key  xhub.subscription . However, for historical reasons\n(primarily that this was not supported in Pubsubhubbub 0.1, and a late addition\nto 0.2 ), it is strongly recommended to use the most compatible means of adding\nthis key to the callback URL by appending it to the URL's path.  Thus the URL  http://www.example.com/callback?xhub.subscription=key  would become http://www.example.com/callback/key .  Since the query string method is the default in anticipation of a greater level\nof future support for the full 0.2/0.3 specification, this requires some\nadditional work to implement.  The first step is to make the  Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback  class\naware of the path contained subscription key. It's manually injected; therefore\nit also requires manually defining a route for this purpose. This is achieved by\ncalled the method  Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback::setSubscriptionKey() \nwith the parameter being the key value available from the router. The example\nbelow demonstrates this using a zend-mvc controller.  use Zend\\Feed\\PubSubHubbub\\Model\\Subscription;\nuse Zend\\Feed\\PubSubHubbub\\Subscriber\\Callback;\nuse Zend\\Mvc\\Controller\\AbstractActionController;\n\nclass CallbackController extends AbstractActionController\n{\n\n    public function indexAction()\n    {\n        $storage = new Subscription();\n        $callback = new Callback();\n        $callback->setStorage($storage);\n\n        /*\n         * Inject subscription key parsing from URL path using\n         * a parameter from the router.\n         */\n        $subscriptionKey = $this->params()->fromRoute('subkey');\n        $callback->setSubscriptionKey($subscriptionKey);\n        $callback->handle();\n        $callback->sendResponse();\n\n        /*\n         * Check if the callback resulting in the receipt of a feed update.\n         * Otherwise it was either a (un)sub verification request or invalid\n         * request. Typically we need do nothing other than add feed update\n         * handling; the rest is handled internally by the class.\n         */\n        if ($callback->hasFeedUpdate()) {\n            $feedString = $callback->getFeedUpdate();\n            /*\n             *  Process the feed update asynchronously to avoid a Hub timeout.\n             */\n        }\n    }\n}  The example below illustrates adding a route mapping the path segment to a route\nparameter, using zend-mvc:  use Zend\\Mvc\\Router\\Http\\Segment as SegmentRoute;;\n\n// Route defininition for enabling appending of a PuSH Subscription's lookup key\n$route = SegmentRoute::factory([\n   'route' => '/callback/:subkey',\n   'constraints' => [\n      'subkey' => '[a-z0-9]+',\n   ],\n   'defaults' => [\n      'controller' => 'application-index',\n      'action' => 'index',\n   ]\n]);",
            "title": "Setting Up And Using A Callback URL Route"
        }
    ]
}